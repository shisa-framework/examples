// generated by "charlatan -output=./registrar_charlatan.go Registrar".  DO NOT EDIT.

package sd

import "net/url"
import "github.com/ansel1/merry"

import "reflect"

// RegistrarRegisterInvocation represents a single call of FakeRegistrar.Register
type RegistrarRegisterInvocation struct {
	Parameters struct {
		ServiceID string
		Url       *url.URL
	}
	Results struct {
		Ident1 merry.Error
	}
}

// NewRegistrarRegisterInvocation creates a new instance of RegistrarRegisterInvocation
func NewRegistrarRegisterInvocation(serviceID string, url *url.URL, ident1 merry.Error) *RegistrarRegisterInvocation {
	invocation := new(RegistrarRegisterInvocation)

	invocation.Parameters.ServiceID = serviceID
	invocation.Parameters.Url = url

	invocation.Results.Ident1 = ident1

	return invocation
}

// RegistrarDeregisterInvocation represents a single call of FakeRegistrar.Deregister
type RegistrarDeregisterInvocation struct {
	Parameters struct {
		ServiceID string
	}
	Results struct {
		Ident1 merry.Error
	}
}

// NewRegistrarDeregisterInvocation creates a new instance of RegistrarDeregisterInvocation
func NewRegistrarDeregisterInvocation(serviceID string, ident1 merry.Error) *RegistrarDeregisterInvocation {
	invocation := new(RegistrarDeregisterInvocation)

	invocation.Parameters.ServiceID = serviceID

	invocation.Results.Ident1 = ident1

	return invocation
}

// RegistrarAddCheckInvocation represents a single call of FakeRegistrar.AddCheck
type RegistrarAddCheckInvocation struct {
	Parameters struct {
		Service string
		Url     *url.URL
	}
	Results struct {
		Ident1 merry.Error
	}
}

// NewRegistrarAddCheckInvocation creates a new instance of RegistrarAddCheckInvocation
func NewRegistrarAddCheckInvocation(service string, url *url.URL, ident1 merry.Error) *RegistrarAddCheckInvocation {
	invocation := new(RegistrarAddCheckInvocation)

	invocation.Parameters.Service = service
	invocation.Parameters.Url = url

	invocation.Results.Ident1 = ident1

	return invocation
}

// RegistrarRemoveChecksInvocation represents a single call of FakeRegistrar.RemoveChecks
type RegistrarRemoveChecksInvocation struct {
	Parameters struct {
		Service string
	}
	Results struct {
		Ident1 merry.Error
	}
}

// NewRegistrarRemoveChecksInvocation creates a new instance of RegistrarRemoveChecksInvocation
func NewRegistrarRemoveChecksInvocation(service string, ident1 merry.Error) *RegistrarRemoveChecksInvocation {
	invocation := new(RegistrarRemoveChecksInvocation)

	invocation.Parameters.Service = service

	invocation.Results.Ident1 = ident1

	return invocation
}

// RegistrarTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type RegistrarTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeRegistrar is a mock implementation of Registrar for testing.
Use it in your tests as in this example:

	package example

	func TestWithRegistrar(t *testing.T) {
		f := &sd.FakeRegistrar{
			RegisterHook: func(serviceID string, url *url.URL) (ident1 merry.Error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeRegister ...
		f.AssertRegisterCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeRegister.
*/
type FakeRegistrar struct {
	RegisterHook     func(string, *url.URL) merry.Error
	DeregisterHook   func(string) merry.Error
	AddCheckHook     func(string, *url.URL) merry.Error
	RemoveChecksHook func(string) merry.Error

	RegisterCalls     []*RegistrarRegisterInvocation
	DeregisterCalls   []*RegistrarDeregisterInvocation
	AddCheckCalls     []*RegistrarAddCheckInvocation
	RemoveChecksCalls []*RegistrarRemoveChecksInvocation
}

// NewFakeRegistrarDefaultPanic returns an instance of FakeRegistrar with all hooks configured to panic
func NewFakeRegistrarDefaultPanic() *FakeRegistrar {
	return &FakeRegistrar{
		RegisterHook: func(string, *url.URL) (ident1 merry.Error) {
			panic("Unexpected call to Registrar.Register")
		},
		DeregisterHook: func(string) (ident1 merry.Error) {
			panic("Unexpected call to Registrar.Deregister")
		},
		AddCheckHook: func(string, *url.URL) (ident1 merry.Error) {
			panic("Unexpected call to Registrar.AddCheck")
		},
		RemoveChecksHook: func(string) (ident1 merry.Error) {
			panic("Unexpected call to Registrar.RemoveChecks")
		},
	}
}

// NewFakeRegistrarDefaultFatal returns an instance of FakeRegistrar with all hooks configured to call t.Fatal
func NewFakeRegistrarDefaultFatal(t RegistrarTestingT) *FakeRegistrar {
	return &FakeRegistrar{
		RegisterHook: func(string, *url.URL) (ident1 merry.Error) {
			t.Fatal("Unexpected call to Registrar.Register")
			return
		},
		DeregisterHook: func(string) (ident1 merry.Error) {
			t.Fatal("Unexpected call to Registrar.Deregister")
			return
		},
		AddCheckHook: func(string, *url.URL) (ident1 merry.Error) {
			t.Fatal("Unexpected call to Registrar.AddCheck")
			return
		},
		RemoveChecksHook: func(string) (ident1 merry.Error) {
			t.Fatal("Unexpected call to Registrar.RemoveChecks")
			return
		},
	}
}

// NewFakeRegistrarDefaultError returns an instance of FakeRegistrar with all hooks configured to call t.Error
func NewFakeRegistrarDefaultError(t RegistrarTestingT) *FakeRegistrar {
	return &FakeRegistrar{
		RegisterHook: func(string, *url.URL) (ident1 merry.Error) {
			t.Error("Unexpected call to Registrar.Register")
			return
		},
		DeregisterHook: func(string) (ident1 merry.Error) {
			t.Error("Unexpected call to Registrar.Deregister")
			return
		},
		AddCheckHook: func(string, *url.URL) (ident1 merry.Error) {
			t.Error("Unexpected call to Registrar.AddCheck")
			return
		},
		RemoveChecksHook: func(string) (ident1 merry.Error) {
			t.Error("Unexpected call to Registrar.RemoveChecks")
			return
		},
	}
}

func (f *FakeRegistrar) Reset() {
	f.RegisterCalls = []*RegistrarRegisterInvocation{}
	f.DeregisterCalls = []*RegistrarDeregisterInvocation{}
	f.AddCheckCalls = []*RegistrarAddCheckInvocation{}
	f.RemoveChecksCalls = []*RegistrarRemoveChecksInvocation{}
}

func (_f1 *FakeRegistrar) Register(serviceID string, url *url.URL) (ident1 merry.Error) {
	if _f1.RegisterHook == nil {
		panic("Registrar.Register() called but FakeRegistrar.RegisterHook is nil")
	}

	invocation := new(RegistrarRegisterInvocation)
	_f1.RegisterCalls = append(_f1.RegisterCalls, invocation)

	invocation.Parameters.ServiceID = serviceID
	invocation.Parameters.Url = url

	ident1 = _f1.RegisterHook(serviceID, url)

	invocation.Results.Ident1 = ident1

	return
}

// SetRegisterStub configures Registrar.Register to always return the given values
func (_f2 *FakeRegistrar) SetRegisterStub(ident1 merry.Error) {
	_f2.RegisterHook = func(string, *url.URL) merry.Error {
		return ident1
	}
}

// SetRegisterInvocation configures Registrar.Register to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f3 *FakeRegistrar) SetRegisterInvocation(calls_f4 []*RegistrarRegisterInvocation, fallback_f5 func() merry.Error) {
	_f3.RegisterHook = func(serviceID string, url *url.URL) (ident1 merry.Error) {
		for _, call := range calls_f4 {
			if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) && reflect.DeepEqual(call.Parameters.Url, url) {
				ident1 = call.Results.Ident1

				return
			}
		}

		return fallback_f5()
	}
}

// RegisterCalled returns true if FakeRegistrar.Register was called
func (f *FakeRegistrar) RegisterCalled() bool {
	return len(f.RegisterCalls) != 0
}

// AssertRegisterCalled calls t.Error if FakeRegistrar.Register was not called
func (f *FakeRegistrar) AssertRegisterCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.RegisterCalls) == 0 {
		t.Error("FakeRegistrar.Register not called, expected at least one")
	}
}

// RegisterNotCalled returns true if FakeRegistrar.Register was not called
func (f *FakeRegistrar) RegisterNotCalled() bool {
	return len(f.RegisterCalls) == 0
}

// AssertRegisterNotCalled calls t.Error if FakeRegistrar.Register was called
func (f *FakeRegistrar) AssertRegisterNotCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.RegisterCalls) != 0 {
		t.Error("FakeRegistrar.Register called, expected none")
	}
}

// RegisterCalledOnce returns true if FakeRegistrar.Register was called exactly once
func (f *FakeRegistrar) RegisterCalledOnce() bool {
	return len(f.RegisterCalls) == 1
}

// AssertRegisterCalledOnce calls t.Error if FakeRegistrar.Register was not called exactly once
func (f *FakeRegistrar) AssertRegisterCalledOnce(t RegistrarTestingT) {
	t.Helper()
	if len(f.RegisterCalls) != 1 {
		t.Errorf("FakeRegistrar.Register called %d times, expected 1", len(f.RegisterCalls))
	}
}

// RegisterCalledN returns true if FakeRegistrar.Register was called at least n times
func (f *FakeRegistrar) RegisterCalledN(n int) bool {
	return len(f.RegisterCalls) >= n
}

// AssertRegisterCalledN calls t.Error if FakeRegistrar.Register was called less than n times
func (f *FakeRegistrar) AssertRegisterCalledN(t RegistrarTestingT, n int) {
	t.Helper()
	if len(f.RegisterCalls) < n {
		t.Errorf("FakeRegistrar.Register called %d times, expected >= %d", len(f.RegisterCalls), n)
	}
}

// RegisterCalledWith returns true if FakeRegistrar.Register was called with the given values
func (_f6 *FakeRegistrar) RegisterCalledWith(serviceID string, url *url.URL) (found bool) {
	for _, call := range _f6.RegisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) && reflect.DeepEqual(call.Parameters.Url, url) {
			found = true
			break
		}
	}

	return
}

// AssertRegisterCalledWith calls t.Error if FakeRegistrar.Register was not called with the given values
func (_f7 *FakeRegistrar) AssertRegisterCalledWith(t RegistrarTestingT, serviceID string, url *url.URL) {
	t.Helper()
	var found bool
	for _, call := range _f7.RegisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) && reflect.DeepEqual(call.Parameters.Url, url) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeRegistrar.Register not called with expected parameters")
	}
}

// RegisterCalledOnceWith returns true if FakeRegistrar.Register was called exactly once with the given values
func (_f8 *FakeRegistrar) RegisterCalledOnceWith(serviceID string, url *url.URL) bool {
	var count int
	for _, call := range _f8.RegisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) && reflect.DeepEqual(call.Parameters.Url, url) {
			count++
		}
	}

	return count == 1
}

// AssertRegisterCalledOnceWith calls t.Error if FakeRegistrar.Register was not called exactly once with the given values
func (_f9 *FakeRegistrar) AssertRegisterCalledOnceWith(t RegistrarTestingT, serviceID string, url *url.URL) {
	t.Helper()
	var count int
	for _, call := range _f9.RegisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) && reflect.DeepEqual(call.Parameters.Url, url) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeRegistrar.Register called %d times with expected parameters, expected one", count)
	}
}

// RegisterResultsForCall returns the result values for the first call to FakeRegistrar.Register with the given values
func (_f10 *FakeRegistrar) RegisterResultsForCall(serviceID string, url *url.URL) (ident1 merry.Error, found bool) {
	for _, call := range _f10.RegisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) && reflect.DeepEqual(call.Parameters.Url, url) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}

func (_f11 *FakeRegistrar) Deregister(serviceID string) (ident1 merry.Error) {
	if _f11.DeregisterHook == nil {
		panic("Registrar.Deregister() called but FakeRegistrar.DeregisterHook is nil")
	}

	invocation := new(RegistrarDeregisterInvocation)
	_f11.DeregisterCalls = append(_f11.DeregisterCalls, invocation)

	invocation.Parameters.ServiceID = serviceID

	ident1 = _f11.DeregisterHook(serviceID)

	invocation.Results.Ident1 = ident1

	return
}

// SetDeregisterStub configures Registrar.Deregister to always return the given values
func (_f12 *FakeRegistrar) SetDeregisterStub(ident1 merry.Error) {
	_f12.DeregisterHook = func(string) merry.Error {
		return ident1
	}
}

// SetDeregisterInvocation configures Registrar.Deregister to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f13 *FakeRegistrar) SetDeregisterInvocation(calls_f14 []*RegistrarDeregisterInvocation, fallback_f15 func() merry.Error) {
	_f13.DeregisterHook = func(serviceID string) (ident1 merry.Error) {
		for _, call := range calls_f14 {
			if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) {
				ident1 = call.Results.Ident1

				return
			}
		}

		return fallback_f15()
	}
}

// DeregisterCalled returns true if FakeRegistrar.Deregister was called
func (f *FakeRegistrar) DeregisterCalled() bool {
	return len(f.DeregisterCalls) != 0
}

// AssertDeregisterCalled calls t.Error if FakeRegistrar.Deregister was not called
func (f *FakeRegistrar) AssertDeregisterCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.DeregisterCalls) == 0 {
		t.Error("FakeRegistrar.Deregister not called, expected at least one")
	}
}

// DeregisterNotCalled returns true if FakeRegistrar.Deregister was not called
func (f *FakeRegistrar) DeregisterNotCalled() bool {
	return len(f.DeregisterCalls) == 0
}

// AssertDeregisterNotCalled calls t.Error if FakeRegistrar.Deregister was called
func (f *FakeRegistrar) AssertDeregisterNotCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.DeregisterCalls) != 0 {
		t.Error("FakeRegistrar.Deregister called, expected none")
	}
}

// DeregisterCalledOnce returns true if FakeRegistrar.Deregister was called exactly once
func (f *FakeRegistrar) DeregisterCalledOnce() bool {
	return len(f.DeregisterCalls) == 1
}

// AssertDeregisterCalledOnce calls t.Error if FakeRegistrar.Deregister was not called exactly once
func (f *FakeRegistrar) AssertDeregisterCalledOnce(t RegistrarTestingT) {
	t.Helper()
	if len(f.DeregisterCalls) != 1 {
		t.Errorf("FakeRegistrar.Deregister called %d times, expected 1", len(f.DeregisterCalls))
	}
}

// DeregisterCalledN returns true if FakeRegistrar.Deregister was called at least n times
func (f *FakeRegistrar) DeregisterCalledN(n int) bool {
	return len(f.DeregisterCalls) >= n
}

// AssertDeregisterCalledN calls t.Error if FakeRegistrar.Deregister was called less than n times
func (f *FakeRegistrar) AssertDeregisterCalledN(t RegistrarTestingT, n int) {
	t.Helper()
	if len(f.DeregisterCalls) < n {
		t.Errorf("FakeRegistrar.Deregister called %d times, expected >= %d", len(f.DeregisterCalls), n)
	}
}

// DeregisterCalledWith returns true if FakeRegistrar.Deregister was called with the given values
func (_f16 *FakeRegistrar) DeregisterCalledWith(serviceID string) (found bool) {
	for _, call := range _f16.DeregisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) {
			found = true
			break
		}
	}

	return
}

// AssertDeregisterCalledWith calls t.Error if FakeRegistrar.Deregister was not called with the given values
func (_f17 *FakeRegistrar) AssertDeregisterCalledWith(t RegistrarTestingT, serviceID string) {
	t.Helper()
	var found bool
	for _, call := range _f17.DeregisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeRegistrar.Deregister not called with expected parameters")
	}
}

// DeregisterCalledOnceWith returns true if FakeRegistrar.Deregister was called exactly once with the given values
func (_f18 *FakeRegistrar) DeregisterCalledOnceWith(serviceID string) bool {
	var count int
	for _, call := range _f18.DeregisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) {
			count++
		}
	}

	return count == 1
}

// AssertDeregisterCalledOnceWith calls t.Error if FakeRegistrar.Deregister was not called exactly once with the given values
func (_f19 *FakeRegistrar) AssertDeregisterCalledOnceWith(t RegistrarTestingT, serviceID string) {
	t.Helper()
	var count int
	for _, call := range _f19.DeregisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeRegistrar.Deregister called %d times with expected parameters, expected one", count)
	}
}

// DeregisterResultsForCall returns the result values for the first call to FakeRegistrar.Deregister with the given values
func (_f20 *FakeRegistrar) DeregisterResultsForCall(serviceID string) (ident1 merry.Error, found bool) {
	for _, call := range _f20.DeregisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}

func (_f21 *FakeRegistrar) AddCheck(service string, url *url.URL) (ident1 merry.Error) {
	if _f21.AddCheckHook == nil {
		panic("Registrar.AddCheck() called but FakeRegistrar.AddCheckHook is nil")
	}

	invocation := new(RegistrarAddCheckInvocation)
	_f21.AddCheckCalls = append(_f21.AddCheckCalls, invocation)

	invocation.Parameters.Service = service
	invocation.Parameters.Url = url

	ident1 = _f21.AddCheckHook(service, url)

	invocation.Results.Ident1 = ident1

	return
}

// SetAddCheckStub configures Registrar.AddCheck to always return the given values
func (_f22 *FakeRegistrar) SetAddCheckStub(ident1 merry.Error) {
	_f22.AddCheckHook = func(string, *url.URL) merry.Error {
		return ident1
	}
}

// SetAddCheckInvocation configures Registrar.AddCheck to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f23 *FakeRegistrar) SetAddCheckInvocation(calls_f24 []*RegistrarAddCheckInvocation, fallback_f25 func() merry.Error) {
	_f23.AddCheckHook = func(service string, url *url.URL) (ident1 merry.Error) {
		for _, call := range calls_f24 {
			if reflect.DeepEqual(call.Parameters.Service, service) && reflect.DeepEqual(call.Parameters.Url, url) {
				ident1 = call.Results.Ident1

				return
			}
		}

		return fallback_f25()
	}
}

// AddCheckCalled returns true if FakeRegistrar.AddCheck was called
func (f *FakeRegistrar) AddCheckCalled() bool {
	return len(f.AddCheckCalls) != 0
}

// AssertAddCheckCalled calls t.Error if FakeRegistrar.AddCheck was not called
func (f *FakeRegistrar) AssertAddCheckCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.AddCheckCalls) == 0 {
		t.Error("FakeRegistrar.AddCheck not called, expected at least one")
	}
}

// AddCheckNotCalled returns true if FakeRegistrar.AddCheck was not called
func (f *FakeRegistrar) AddCheckNotCalled() bool {
	return len(f.AddCheckCalls) == 0
}

// AssertAddCheckNotCalled calls t.Error if FakeRegistrar.AddCheck was called
func (f *FakeRegistrar) AssertAddCheckNotCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.AddCheckCalls) != 0 {
		t.Error("FakeRegistrar.AddCheck called, expected none")
	}
}

// AddCheckCalledOnce returns true if FakeRegistrar.AddCheck was called exactly once
func (f *FakeRegistrar) AddCheckCalledOnce() bool {
	return len(f.AddCheckCalls) == 1
}

// AssertAddCheckCalledOnce calls t.Error if FakeRegistrar.AddCheck was not called exactly once
func (f *FakeRegistrar) AssertAddCheckCalledOnce(t RegistrarTestingT) {
	t.Helper()
	if len(f.AddCheckCalls) != 1 {
		t.Errorf("FakeRegistrar.AddCheck called %d times, expected 1", len(f.AddCheckCalls))
	}
}

// AddCheckCalledN returns true if FakeRegistrar.AddCheck was called at least n times
func (f *FakeRegistrar) AddCheckCalledN(n int) bool {
	return len(f.AddCheckCalls) >= n
}

// AssertAddCheckCalledN calls t.Error if FakeRegistrar.AddCheck was called less than n times
func (f *FakeRegistrar) AssertAddCheckCalledN(t RegistrarTestingT, n int) {
	t.Helper()
	if len(f.AddCheckCalls) < n {
		t.Errorf("FakeRegistrar.AddCheck called %d times, expected >= %d", len(f.AddCheckCalls), n)
	}
}

// AddCheckCalledWith returns true if FakeRegistrar.AddCheck was called with the given values
func (_f26 *FakeRegistrar) AddCheckCalledWith(service string, url *url.URL) (found bool) {
	for _, call := range _f26.AddCheckCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) && reflect.DeepEqual(call.Parameters.Url, url) {
			found = true
			break
		}
	}

	return
}

// AssertAddCheckCalledWith calls t.Error if FakeRegistrar.AddCheck was not called with the given values
func (_f27 *FakeRegistrar) AssertAddCheckCalledWith(t RegistrarTestingT, service string, url *url.URL) {
	t.Helper()
	var found bool
	for _, call := range _f27.AddCheckCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) && reflect.DeepEqual(call.Parameters.Url, url) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeRegistrar.AddCheck not called with expected parameters")
	}
}

// AddCheckCalledOnceWith returns true if FakeRegistrar.AddCheck was called exactly once with the given values
func (_f28 *FakeRegistrar) AddCheckCalledOnceWith(service string, url *url.URL) bool {
	var count int
	for _, call := range _f28.AddCheckCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) && reflect.DeepEqual(call.Parameters.Url, url) {
			count++
		}
	}

	return count == 1
}

// AssertAddCheckCalledOnceWith calls t.Error if FakeRegistrar.AddCheck was not called exactly once with the given values
func (_f29 *FakeRegistrar) AssertAddCheckCalledOnceWith(t RegistrarTestingT, service string, url *url.URL) {
	t.Helper()
	var count int
	for _, call := range _f29.AddCheckCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) && reflect.DeepEqual(call.Parameters.Url, url) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeRegistrar.AddCheck called %d times with expected parameters, expected one", count)
	}
}

// AddCheckResultsForCall returns the result values for the first call to FakeRegistrar.AddCheck with the given values
func (_f30 *FakeRegistrar) AddCheckResultsForCall(service string, url *url.URL) (ident1 merry.Error, found bool) {
	for _, call := range _f30.AddCheckCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) && reflect.DeepEqual(call.Parameters.Url, url) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}

func (_f31 *FakeRegistrar) RemoveChecks(service string) (ident1 merry.Error) {
	if _f31.RemoveChecksHook == nil {
		panic("Registrar.RemoveChecks() called but FakeRegistrar.RemoveChecksHook is nil")
	}

	invocation := new(RegistrarRemoveChecksInvocation)
	_f31.RemoveChecksCalls = append(_f31.RemoveChecksCalls, invocation)

	invocation.Parameters.Service = service

	ident1 = _f31.RemoveChecksHook(service)

	invocation.Results.Ident1 = ident1

	return
}

// SetRemoveChecksStub configures Registrar.RemoveChecks to always return the given values
func (_f32 *FakeRegistrar) SetRemoveChecksStub(ident1 merry.Error) {
	_f32.RemoveChecksHook = func(string) merry.Error {
		return ident1
	}
}

// SetRemoveChecksInvocation configures Registrar.RemoveChecks to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f33 *FakeRegistrar) SetRemoveChecksInvocation(calls_f34 []*RegistrarRemoveChecksInvocation, fallback_f35 func() merry.Error) {
	_f33.RemoveChecksHook = func(service string) (ident1 merry.Error) {
		for _, call := range calls_f34 {
			if reflect.DeepEqual(call.Parameters.Service, service) {
				ident1 = call.Results.Ident1

				return
			}
		}

		return fallback_f35()
	}
}

// RemoveChecksCalled returns true if FakeRegistrar.RemoveChecks was called
func (f *FakeRegistrar) RemoveChecksCalled() bool {
	return len(f.RemoveChecksCalls) != 0
}

// AssertRemoveChecksCalled calls t.Error if FakeRegistrar.RemoveChecks was not called
func (f *FakeRegistrar) AssertRemoveChecksCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.RemoveChecksCalls) == 0 {
		t.Error("FakeRegistrar.RemoveChecks not called, expected at least one")
	}
}

// RemoveChecksNotCalled returns true if FakeRegistrar.RemoveChecks was not called
func (f *FakeRegistrar) RemoveChecksNotCalled() bool {
	return len(f.RemoveChecksCalls) == 0
}

// AssertRemoveChecksNotCalled calls t.Error if FakeRegistrar.RemoveChecks was called
func (f *FakeRegistrar) AssertRemoveChecksNotCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.RemoveChecksCalls) != 0 {
		t.Error("FakeRegistrar.RemoveChecks called, expected none")
	}
}

// RemoveChecksCalledOnce returns true if FakeRegistrar.RemoveChecks was called exactly once
func (f *FakeRegistrar) RemoveChecksCalledOnce() bool {
	return len(f.RemoveChecksCalls) == 1
}

// AssertRemoveChecksCalledOnce calls t.Error if FakeRegistrar.RemoveChecks was not called exactly once
func (f *FakeRegistrar) AssertRemoveChecksCalledOnce(t RegistrarTestingT) {
	t.Helper()
	if len(f.RemoveChecksCalls) != 1 {
		t.Errorf("FakeRegistrar.RemoveChecks called %d times, expected 1", len(f.RemoveChecksCalls))
	}
}

// RemoveChecksCalledN returns true if FakeRegistrar.RemoveChecks was called at least n times
func (f *FakeRegistrar) RemoveChecksCalledN(n int) bool {
	return len(f.RemoveChecksCalls) >= n
}

// AssertRemoveChecksCalledN calls t.Error if FakeRegistrar.RemoveChecks was called less than n times
func (f *FakeRegistrar) AssertRemoveChecksCalledN(t RegistrarTestingT, n int) {
	t.Helper()
	if len(f.RemoveChecksCalls) < n {
		t.Errorf("FakeRegistrar.RemoveChecks called %d times, expected >= %d", len(f.RemoveChecksCalls), n)
	}
}

// RemoveChecksCalledWith returns true if FakeRegistrar.RemoveChecks was called with the given values
func (_f36 *FakeRegistrar) RemoveChecksCalledWith(service string) (found bool) {
	for _, call := range _f36.RemoveChecksCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) {
			found = true
			break
		}
	}

	return
}

// AssertRemoveChecksCalledWith calls t.Error if FakeRegistrar.RemoveChecks was not called with the given values
func (_f37 *FakeRegistrar) AssertRemoveChecksCalledWith(t RegistrarTestingT, service string) {
	t.Helper()
	var found bool
	for _, call := range _f37.RemoveChecksCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeRegistrar.RemoveChecks not called with expected parameters")
	}
}

// RemoveChecksCalledOnceWith returns true if FakeRegistrar.RemoveChecks was called exactly once with the given values
func (_f38 *FakeRegistrar) RemoveChecksCalledOnceWith(service string) bool {
	var count int
	for _, call := range _f38.RemoveChecksCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) {
			count++
		}
	}

	return count == 1
}

// AssertRemoveChecksCalledOnceWith calls t.Error if FakeRegistrar.RemoveChecks was not called exactly once with the given values
func (_f39 *FakeRegistrar) AssertRemoveChecksCalledOnceWith(t RegistrarTestingT, service string) {
	t.Helper()
	var count int
	for _, call := range _f39.RemoveChecksCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeRegistrar.RemoveChecks called %d times with expected parameters, expected one", count)
	}
}

// RemoveChecksResultsForCall returns the result values for the first call to FakeRegistrar.RemoveChecks with the given values
func (_f40 *FakeRegistrar) RemoveChecksResultsForCall(service string) (ident1 merry.Error, found bool) {
	for _, call := range _f40.RemoveChecksCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}
