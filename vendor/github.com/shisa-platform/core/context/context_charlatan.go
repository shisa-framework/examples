// generated by "charlatan -output=./context_charlatan.go Context".  DO NOT EDIT.

package context

import "reflect"
import "context"
import "time"
import "github.com/opentracing/opentracing-go"
import "github.com/shisa-platform/core/models"

// ContextDeadlineInvocation represents a single call of FakeContext.Deadline
type ContextDeadlineInvocation struct {
	Results struct {
		Deadline time.Time
		Ok       bool
	}
}

// ContextDoneInvocation represents a single call of FakeContext.Done
type ContextDoneInvocation struct {
	Results struct {
		Ident1 <-chan struct{}
	}
}

// ContextErrInvocation represents a single call of FakeContext.Err
type ContextErrInvocation struct {
	Results struct {
		Ident2 error
	}
}

// ContextValueInvocation represents a single call of FakeContext.Value
type ContextValueInvocation struct {
	Parameters struct {
		Key interface{}
	}
	Results struct {
		Ident3 interface{}
	}
}

// NewContextValueInvocation creates a new instance of ContextValueInvocation
func NewContextValueInvocation(key interface{}, ident3 interface{}) *ContextValueInvocation {
	invocation := new(ContextValueInvocation)

	invocation.Parameters.Key = key

	invocation.Results.Ident3 = ident3

	return invocation
}

// ContextRequestIDInvocation represents a single call of FakeContext.RequestID
type ContextRequestIDInvocation struct {
	Results struct {
		Ident1 string
	}
}

// ContextActorInvocation represents a single call of FakeContext.Actor
type ContextActorInvocation struct {
	Results struct {
		Ident1 models.User
	}
}

// ContextSpanInvocation represents a single call of FakeContext.Span
type ContextSpanInvocation struct {
	Results struct {
		Ident1 opentracing.Span
	}
}

// ContextStartSpanInvocation represents a single call of FakeContext.StartSpan
type ContextStartSpanInvocation struct {
	Parameters struct {
		Ident1 string
		Ident2 []opentracing.StartSpanOption
	}
	Results struct {
		Ident3 opentracing.Span
	}
}

// NewContextStartSpanInvocation creates a new instance of ContextStartSpanInvocation
func NewContextStartSpanInvocation(ident1 string, ident2 []opentracing.StartSpanOption, ident3 opentracing.Span) *ContextStartSpanInvocation {
	invocation := new(ContextStartSpanInvocation)

	invocation.Parameters.Ident1 = ident1
	invocation.Parameters.Ident2 = ident2

	invocation.Results.Ident3 = ident3

	return invocation
}

// ContextWithParentInvocation represents a single call of FakeContext.WithParent
type ContextWithParentInvocation struct {
	Parameters struct {
		Ident1 context.Context
	}
	Results struct {
		Ident2 Context
	}
}

// NewContextWithParentInvocation creates a new instance of ContextWithParentInvocation
func NewContextWithParentInvocation(ident1 context.Context, ident2 Context) *ContextWithParentInvocation {
	invocation := new(ContextWithParentInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2

	return invocation
}

// ContextWithActorInvocation represents a single call of FakeContext.WithActor
type ContextWithActorInvocation struct {
	Parameters struct {
		Ident1 models.User
	}
	Results struct {
		Ident2 Context
	}
}

// NewContextWithActorInvocation creates a new instance of ContextWithActorInvocation
func NewContextWithActorInvocation(ident1 models.User, ident2 Context) *ContextWithActorInvocation {
	invocation := new(ContextWithActorInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2

	return invocation
}

// ContextWithRequestIDInvocation represents a single call of FakeContext.WithRequestID
type ContextWithRequestIDInvocation struct {
	Parameters struct {
		Ident1 string
	}
	Results struct {
		Ident2 Context
	}
}

// NewContextWithRequestIDInvocation creates a new instance of ContextWithRequestIDInvocation
func NewContextWithRequestIDInvocation(ident1 string, ident2 Context) *ContextWithRequestIDInvocation {
	invocation := new(ContextWithRequestIDInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2

	return invocation
}

// ContextWithSpanInvocation represents a single call of FakeContext.WithSpan
type ContextWithSpanInvocation struct {
	Parameters struct {
		Ident1 opentracing.Span
	}
	Results struct {
		Ident2 Context
	}
}

// NewContextWithSpanInvocation creates a new instance of ContextWithSpanInvocation
func NewContextWithSpanInvocation(ident1 opentracing.Span, ident2 Context) *ContextWithSpanInvocation {
	invocation := new(ContextWithSpanInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2

	return invocation
}

// ContextWithValueInvocation represents a single call of FakeContext.WithValue
type ContextWithValueInvocation struct {
	Parameters struct {
		Key   interface{}
		Value interface{}
	}
	Results struct {
		Ident1 Context
	}
}

// NewContextWithValueInvocation creates a new instance of ContextWithValueInvocation
func NewContextWithValueInvocation(key interface{}, value interface{}, ident1 Context) *ContextWithValueInvocation {
	invocation := new(ContextWithValueInvocation)

	invocation.Parameters.Key = key
	invocation.Parameters.Value = value

	invocation.Results.Ident1 = ident1

	return invocation
}

// ContextWithCancelInvocation represents a single call of FakeContext.WithCancel
type ContextWithCancelInvocation struct {
	Results struct {
		Ident1 Context
		Ident2 context.CancelFunc
	}
}

// ContextWithDeadlineInvocation represents a single call of FakeContext.WithDeadline
type ContextWithDeadlineInvocation struct {
	Parameters struct {
		Ident1 time.Time
	}
	Results struct {
		Ident2 Context
		Ident3 context.CancelFunc
	}
}

// NewContextWithDeadlineInvocation creates a new instance of ContextWithDeadlineInvocation
func NewContextWithDeadlineInvocation(ident1 time.Time, ident2 Context, ident3 context.CancelFunc) *ContextWithDeadlineInvocation {
	invocation := new(ContextWithDeadlineInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3

	return invocation
}

// ContextWithTimeoutInvocation represents a single call of FakeContext.WithTimeout
type ContextWithTimeoutInvocation struct {
	Parameters struct {
		Ident1 time.Duration
	}
	Results struct {
		Ident2 Context
		Ident3 context.CancelFunc
	}
}

// NewContextWithTimeoutInvocation creates a new instance of ContextWithTimeoutInvocation
func NewContextWithTimeoutInvocation(ident1 time.Duration, ident2 Context, ident3 context.CancelFunc) *ContextWithTimeoutInvocation {
	invocation := new(ContextWithTimeoutInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3

	return invocation
}

// ContextTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type ContextTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeContext is a mock implementation of Context for testing.
Use it in your tests as in this example:

	package example

	func TestWithContext(t *testing.T) {
		f := &context.FakeContext{
			DeadlineHook: func() (deadline time.Time, ok bool) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeDeadline ...
		f.AssertDeadlineCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeDeadline.
*/
type FakeContext struct {
	DeadlineHook      func() (time.Time, bool)
	DoneHook          func() <-chan struct{}
	ErrHook           func() error
	ValueHook         func(interface{}) interface{}
	RequestIDHook     func() string
	ActorHook         func() models.User
	SpanHook          func() opentracing.Span
	StartSpanHook     func(string, ...opentracing.StartSpanOption) opentracing.Span
	WithParentHook    func(context.Context) Context
	WithActorHook     func(models.User) Context
	WithRequestIDHook func(string) Context
	WithSpanHook      func(opentracing.Span) Context
	WithValueHook     func(interface{}, interface{}) Context
	WithCancelHook    func() (Context, context.CancelFunc)
	WithDeadlineHook  func(time.Time) (Context, context.CancelFunc)
	WithTimeoutHook   func(time.Duration) (Context, context.CancelFunc)

	DeadlineCalls      []*ContextDeadlineInvocation
	DoneCalls          []*ContextDoneInvocation
	ErrCalls           []*ContextErrInvocation
	ValueCalls         []*ContextValueInvocation
	RequestIDCalls     []*ContextRequestIDInvocation
	ActorCalls         []*ContextActorInvocation
	SpanCalls          []*ContextSpanInvocation
	StartSpanCalls     []*ContextStartSpanInvocation
	WithParentCalls    []*ContextWithParentInvocation
	WithActorCalls     []*ContextWithActorInvocation
	WithRequestIDCalls []*ContextWithRequestIDInvocation
	WithSpanCalls      []*ContextWithSpanInvocation
	WithValueCalls     []*ContextWithValueInvocation
	WithCancelCalls    []*ContextWithCancelInvocation
	WithDeadlineCalls  []*ContextWithDeadlineInvocation
	WithTimeoutCalls   []*ContextWithTimeoutInvocation
}

// NewFakeContextDefaultPanic returns an instance of FakeContext with all hooks configured to panic
func NewFakeContextDefaultPanic() *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			panic("Unexpected call to Context.Deadline")
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			panic("Unexpected call to Context.Done")
		},
		ErrHook: func() (ident2 error) {
			panic("Unexpected call to Context.Err")
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			panic("Unexpected call to Context.Value")
		},
		RequestIDHook: func() (ident1 string) {
			panic("Unexpected call to Context.RequestID")
		},
		ActorHook: func() (ident1 models.User) {
			panic("Unexpected call to Context.Actor")
		},
		SpanHook: func() (ident1 opentracing.Span) {
			panic("Unexpected call to Context.Span")
		},
		StartSpanHook: func(string, ...opentracing.StartSpanOption) (ident3 opentracing.Span) {
			panic("Unexpected call to Context.StartSpan")
		},
		WithParentHook: func(context.Context) (ident2 Context) {
			panic("Unexpected call to Context.WithParent")
		},
		WithActorHook: func(models.User) (ident2 Context) {
			panic("Unexpected call to Context.WithActor")
		},
		WithRequestIDHook: func(string) (ident2 Context) {
			panic("Unexpected call to Context.WithRequestID")
		},
		WithSpanHook: func(opentracing.Span) (ident2 Context) {
			panic("Unexpected call to Context.WithSpan")
		},
		WithValueHook: func(interface{}, interface{}) (ident1 Context) {
			panic("Unexpected call to Context.WithValue")
		},
		WithCancelHook: func() (ident1 Context, ident2 context.CancelFunc) {
			panic("Unexpected call to Context.WithCancel")
		},
		WithDeadlineHook: func(time.Time) (ident2 Context, ident3 context.CancelFunc) {
			panic("Unexpected call to Context.WithDeadline")
		},
		WithTimeoutHook: func(time.Duration) (ident2 Context, ident3 context.CancelFunc) {
			panic("Unexpected call to Context.WithTimeout")
		},
	}
}

// NewFakeContextDefaultFatal returns an instance of FakeContext with all hooks configured to call t.Fatal
func NewFakeContextDefaultFatal(t ContextTestingT) *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			t.Fatal("Unexpected call to Context.Deadline")
			return
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			t.Fatal("Unexpected call to Context.Done")
			return
		},
		ErrHook: func() (ident2 error) {
			t.Fatal("Unexpected call to Context.Err")
			return
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			t.Fatal("Unexpected call to Context.Value")
			return
		},
		RequestIDHook: func() (ident1 string) {
			t.Fatal("Unexpected call to Context.RequestID")
			return
		},
		ActorHook: func() (ident1 models.User) {
			t.Fatal("Unexpected call to Context.Actor")
			return
		},
		SpanHook: func() (ident1 opentracing.Span) {
			t.Fatal("Unexpected call to Context.Span")
			return
		},
		StartSpanHook: func(string, ...opentracing.StartSpanOption) (ident3 opentracing.Span) {
			t.Fatal("Unexpected call to Context.StartSpan")
			return
		},
		WithParentHook: func(context.Context) (ident2 Context) {
			t.Fatal("Unexpected call to Context.WithParent")
			return
		},
		WithActorHook: func(models.User) (ident2 Context) {
			t.Fatal("Unexpected call to Context.WithActor")
			return
		},
		WithRequestIDHook: func(string) (ident2 Context) {
			t.Fatal("Unexpected call to Context.WithRequestID")
			return
		},
		WithSpanHook: func(opentracing.Span) (ident2 Context) {
			t.Fatal("Unexpected call to Context.WithSpan")
			return
		},
		WithValueHook: func(interface{}, interface{}) (ident1 Context) {
			t.Fatal("Unexpected call to Context.WithValue")
			return
		},
		WithCancelHook: func() (ident1 Context, ident2 context.CancelFunc) {
			t.Fatal("Unexpected call to Context.WithCancel")
			return
		},
		WithDeadlineHook: func(time.Time) (ident2 Context, ident3 context.CancelFunc) {
			t.Fatal("Unexpected call to Context.WithDeadline")
			return
		},
		WithTimeoutHook: func(time.Duration) (ident2 Context, ident3 context.CancelFunc) {
			t.Fatal("Unexpected call to Context.WithTimeout")
			return
		},
	}
}

// NewFakeContextDefaultError returns an instance of FakeContext with all hooks configured to call t.Error
func NewFakeContextDefaultError(t ContextTestingT) *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			t.Error("Unexpected call to Context.Deadline")
			return
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			t.Error("Unexpected call to Context.Done")
			return
		},
		ErrHook: func() (ident2 error) {
			t.Error("Unexpected call to Context.Err")
			return
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			t.Error("Unexpected call to Context.Value")
			return
		},
		RequestIDHook: func() (ident1 string) {
			t.Error("Unexpected call to Context.RequestID")
			return
		},
		ActorHook: func() (ident1 models.User) {
			t.Error("Unexpected call to Context.Actor")
			return
		},
		SpanHook: func() (ident1 opentracing.Span) {
			t.Error("Unexpected call to Context.Span")
			return
		},
		StartSpanHook: func(string, ...opentracing.StartSpanOption) (ident3 opentracing.Span) {
			t.Error("Unexpected call to Context.StartSpan")
			return
		},
		WithParentHook: func(context.Context) (ident2 Context) {
			t.Error("Unexpected call to Context.WithParent")
			return
		},
		WithActorHook: func(models.User) (ident2 Context) {
			t.Error("Unexpected call to Context.WithActor")
			return
		},
		WithRequestIDHook: func(string) (ident2 Context) {
			t.Error("Unexpected call to Context.WithRequestID")
			return
		},
		WithSpanHook: func(opentracing.Span) (ident2 Context) {
			t.Error("Unexpected call to Context.WithSpan")
			return
		},
		WithValueHook: func(interface{}, interface{}) (ident1 Context) {
			t.Error("Unexpected call to Context.WithValue")
			return
		},
		WithCancelHook: func() (ident1 Context, ident2 context.CancelFunc) {
			t.Error("Unexpected call to Context.WithCancel")
			return
		},
		WithDeadlineHook: func(time.Time) (ident2 Context, ident3 context.CancelFunc) {
			t.Error("Unexpected call to Context.WithDeadline")
			return
		},
		WithTimeoutHook: func(time.Duration) (ident2 Context, ident3 context.CancelFunc) {
			t.Error("Unexpected call to Context.WithTimeout")
			return
		},
	}
}

func (f *FakeContext) Reset() {
	f.DeadlineCalls = []*ContextDeadlineInvocation{}
	f.DoneCalls = []*ContextDoneInvocation{}
	f.ErrCalls = []*ContextErrInvocation{}
	f.ValueCalls = []*ContextValueInvocation{}
	f.RequestIDCalls = []*ContextRequestIDInvocation{}
	f.ActorCalls = []*ContextActorInvocation{}
	f.SpanCalls = []*ContextSpanInvocation{}
	f.StartSpanCalls = []*ContextStartSpanInvocation{}
	f.WithParentCalls = []*ContextWithParentInvocation{}
	f.WithActorCalls = []*ContextWithActorInvocation{}
	f.WithRequestIDCalls = []*ContextWithRequestIDInvocation{}
	f.WithSpanCalls = []*ContextWithSpanInvocation{}
	f.WithValueCalls = []*ContextWithValueInvocation{}
	f.WithCancelCalls = []*ContextWithCancelInvocation{}
	f.WithDeadlineCalls = []*ContextWithDeadlineInvocation{}
	f.WithTimeoutCalls = []*ContextWithTimeoutInvocation{}
}

func (_f1 *FakeContext) Deadline() (deadline time.Time, ok bool) {
	if _f1.DeadlineHook == nil {
		panic("Context.Deadline() called but FakeContext.DeadlineHook is nil")
	}

	invocation := new(ContextDeadlineInvocation)
	_f1.DeadlineCalls = append(_f1.DeadlineCalls, invocation)

	deadline, ok = _f1.DeadlineHook()

	invocation.Results.Deadline = deadline
	invocation.Results.Ok = ok

	return
}

// SetDeadlineStub configures Context.Deadline to always return the given values
func (_f2 *FakeContext) SetDeadlineStub(deadline time.Time, ok bool) {
	_f2.DeadlineHook = func() (time.Time, bool) {
		return deadline, ok
	}
}

// DeadlineCalled returns true if FakeContext.Deadline was called
func (f *FakeContext) DeadlineCalled() bool {
	return len(f.DeadlineCalls) != 0
}

// AssertDeadlineCalled calls t.Error if FakeContext.Deadline was not called
func (f *FakeContext) AssertDeadlineCalled(t ContextTestingT) {
	t.Helper()
	if len(f.DeadlineCalls) == 0 {
		t.Error("FakeContext.Deadline not called, expected at least one")
	}
}

// DeadlineNotCalled returns true if FakeContext.Deadline was not called
func (f *FakeContext) DeadlineNotCalled() bool {
	return len(f.DeadlineCalls) == 0
}

// AssertDeadlineNotCalled calls t.Error if FakeContext.Deadline was called
func (f *FakeContext) AssertDeadlineNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.DeadlineCalls) != 0 {
		t.Error("FakeContext.Deadline called, expected none")
	}
}

// DeadlineCalledOnce returns true if FakeContext.Deadline was called exactly once
func (f *FakeContext) DeadlineCalledOnce() bool {
	return len(f.DeadlineCalls) == 1
}

// AssertDeadlineCalledOnce calls t.Error if FakeContext.Deadline was not called exactly once
func (f *FakeContext) AssertDeadlineCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.DeadlineCalls) != 1 {
		t.Errorf("FakeContext.Deadline called %d times, expected 1", len(f.DeadlineCalls))
	}
}

// DeadlineCalledN returns true if FakeContext.Deadline was called at least n times
func (f *FakeContext) DeadlineCalledN(n int) bool {
	return len(f.DeadlineCalls) >= n
}

// AssertDeadlineCalledN calls t.Error if FakeContext.Deadline was called less than n times
func (f *FakeContext) AssertDeadlineCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.DeadlineCalls) < n {
		t.Errorf("FakeContext.Deadline called %d times, expected >= %d", len(f.DeadlineCalls), n)
	}
}

func (_f3 *FakeContext) Done() (ident1 <-chan struct{}) {
	if _f3.DoneHook == nil {
		panic("Context.Done() called but FakeContext.DoneHook is nil")
	}

	invocation := new(ContextDoneInvocation)
	_f3.DoneCalls = append(_f3.DoneCalls, invocation)

	ident1 = _f3.DoneHook()

	invocation.Results.Ident1 = ident1

	return
}

// SetDoneStub configures Context.Done to always return the given values
func (_f4 *FakeContext) SetDoneStub(ident1 <-chan struct{}) {
	_f4.DoneHook = func() <-chan struct{} {
		return ident1
	}
}

// DoneCalled returns true if FakeContext.Done was called
func (f *FakeContext) DoneCalled() bool {
	return len(f.DoneCalls) != 0
}

// AssertDoneCalled calls t.Error if FakeContext.Done was not called
func (f *FakeContext) AssertDoneCalled(t ContextTestingT) {
	t.Helper()
	if len(f.DoneCalls) == 0 {
		t.Error("FakeContext.Done not called, expected at least one")
	}
}

// DoneNotCalled returns true if FakeContext.Done was not called
func (f *FakeContext) DoneNotCalled() bool {
	return len(f.DoneCalls) == 0
}

// AssertDoneNotCalled calls t.Error if FakeContext.Done was called
func (f *FakeContext) AssertDoneNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.DoneCalls) != 0 {
		t.Error("FakeContext.Done called, expected none")
	}
}

// DoneCalledOnce returns true if FakeContext.Done was called exactly once
func (f *FakeContext) DoneCalledOnce() bool {
	return len(f.DoneCalls) == 1
}

// AssertDoneCalledOnce calls t.Error if FakeContext.Done was not called exactly once
func (f *FakeContext) AssertDoneCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.DoneCalls) != 1 {
		t.Errorf("FakeContext.Done called %d times, expected 1", len(f.DoneCalls))
	}
}

// DoneCalledN returns true if FakeContext.Done was called at least n times
func (f *FakeContext) DoneCalledN(n int) bool {
	return len(f.DoneCalls) >= n
}

// AssertDoneCalledN calls t.Error if FakeContext.Done was called less than n times
func (f *FakeContext) AssertDoneCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.DoneCalls) < n {
		t.Errorf("FakeContext.Done called %d times, expected >= %d", len(f.DoneCalls), n)
	}
}

func (_f5 *FakeContext) Err() (ident2 error) {
	if _f5.ErrHook == nil {
		panic("Context.Err() called but FakeContext.ErrHook is nil")
	}

	invocation := new(ContextErrInvocation)
	_f5.ErrCalls = append(_f5.ErrCalls, invocation)

	ident2 = _f5.ErrHook()

	invocation.Results.Ident2 = ident2

	return
}

// SetErrStub configures Context.Err to always return the given values
func (_f6 *FakeContext) SetErrStub(ident2 error) {
	_f6.ErrHook = func() error {
		return ident2
	}
}

// ErrCalled returns true if FakeContext.Err was called
func (f *FakeContext) ErrCalled() bool {
	return len(f.ErrCalls) != 0
}

// AssertErrCalled calls t.Error if FakeContext.Err was not called
func (f *FakeContext) AssertErrCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ErrCalls) == 0 {
		t.Error("FakeContext.Err not called, expected at least one")
	}
}

// ErrNotCalled returns true if FakeContext.Err was not called
func (f *FakeContext) ErrNotCalled() bool {
	return len(f.ErrCalls) == 0
}

// AssertErrNotCalled calls t.Error if FakeContext.Err was called
func (f *FakeContext) AssertErrNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ErrCalls) != 0 {
		t.Error("FakeContext.Err called, expected none")
	}
}

// ErrCalledOnce returns true if FakeContext.Err was called exactly once
func (f *FakeContext) ErrCalledOnce() bool {
	return len(f.ErrCalls) == 1
}

// AssertErrCalledOnce calls t.Error if FakeContext.Err was not called exactly once
func (f *FakeContext) AssertErrCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.ErrCalls) != 1 {
		t.Errorf("FakeContext.Err called %d times, expected 1", len(f.ErrCalls))
	}
}

// ErrCalledN returns true if FakeContext.Err was called at least n times
func (f *FakeContext) ErrCalledN(n int) bool {
	return len(f.ErrCalls) >= n
}

// AssertErrCalledN calls t.Error if FakeContext.Err was called less than n times
func (f *FakeContext) AssertErrCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.ErrCalls) < n {
		t.Errorf("FakeContext.Err called %d times, expected >= %d", len(f.ErrCalls), n)
	}
}

func (_f7 *FakeContext) Value(key interface{}) (ident3 interface{}) {
	if _f7.ValueHook == nil {
		panic("Context.Value() called but FakeContext.ValueHook is nil")
	}

	invocation := new(ContextValueInvocation)
	_f7.ValueCalls = append(_f7.ValueCalls, invocation)

	invocation.Parameters.Key = key

	ident3 = _f7.ValueHook(key)

	invocation.Results.Ident3 = ident3

	return
}

// SetValueStub configures Context.Value to always return the given values
func (_f8 *FakeContext) SetValueStub(ident3 interface{}) {
	_f8.ValueHook = func(interface{}) interface{} {
		return ident3
	}
}

// SetValueInvocation configures Context.Value to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f9 *FakeContext) SetValueInvocation(calls_f10 []*ContextValueInvocation, fallback_f11 func() interface{}) {
	_f9.ValueHook = func(key interface{}) (ident3 interface{}) {
		for _, call := range calls_f10 {
			if reflect.DeepEqual(call.Parameters.Key, key) {
				ident3 = call.Results.Ident3

				return
			}
		}

		return fallback_f11()
	}
}

// ValueCalled returns true if FakeContext.Value was called
func (f *FakeContext) ValueCalled() bool {
	return len(f.ValueCalls) != 0
}

// AssertValueCalled calls t.Error if FakeContext.Value was not called
func (f *FakeContext) AssertValueCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ValueCalls) == 0 {
		t.Error("FakeContext.Value not called, expected at least one")
	}
}

// ValueNotCalled returns true if FakeContext.Value was not called
func (f *FakeContext) ValueNotCalled() bool {
	return len(f.ValueCalls) == 0
}

// AssertValueNotCalled calls t.Error if FakeContext.Value was called
func (f *FakeContext) AssertValueNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ValueCalls) != 0 {
		t.Error("FakeContext.Value called, expected none")
	}
}

// ValueCalledOnce returns true if FakeContext.Value was called exactly once
func (f *FakeContext) ValueCalledOnce() bool {
	return len(f.ValueCalls) == 1
}

// AssertValueCalledOnce calls t.Error if FakeContext.Value was not called exactly once
func (f *FakeContext) AssertValueCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.ValueCalls) != 1 {
		t.Errorf("FakeContext.Value called %d times, expected 1", len(f.ValueCalls))
	}
}

// ValueCalledN returns true if FakeContext.Value was called at least n times
func (f *FakeContext) ValueCalledN(n int) bool {
	return len(f.ValueCalls) >= n
}

// AssertValueCalledN calls t.Error if FakeContext.Value was called less than n times
func (f *FakeContext) AssertValueCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.ValueCalls) < n {
		t.Errorf("FakeContext.Value called %d times, expected >= %d", len(f.ValueCalls), n)
	}
}

// ValueCalledWith returns true if FakeContext.Value was called with the given values
func (_f12 *FakeContext) ValueCalledWith(key interface{}) (found bool) {
	for _, call := range _f12.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			found = true
			break
		}
	}

	return
}

// AssertValueCalledWith calls t.Error if FakeContext.Value was not called with the given values
func (_f13 *FakeContext) AssertValueCalledWith(t ContextTestingT, key interface{}) {
	t.Helper()
	var found bool
	for _, call := range _f13.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.Value not called with expected parameters")
	}
}

// ValueCalledOnceWith returns true if FakeContext.Value was called exactly once with the given values
func (_f14 *FakeContext) ValueCalledOnceWith(key interface{}) bool {
	var count int
	for _, call := range _f14.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			count++
		}
	}

	return count == 1
}

// AssertValueCalledOnceWith calls t.Error if FakeContext.Value was not called exactly once with the given values
func (_f15 *FakeContext) AssertValueCalledOnceWith(t ContextTestingT, key interface{}) {
	t.Helper()
	var count int
	for _, call := range _f15.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.Value called %d times with expected parameters, expected one", count)
	}
}

// ValueResultsForCall returns the result values for the first call to FakeContext.Value with the given values
func (_f16 *FakeContext) ValueResultsForCall(key interface{}) (ident3 interface{}, found bool) {
	for _, call := range _f16.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			ident3 = call.Results.Ident3
			found = true
			break
		}
	}

	return
}

func (_f17 *FakeContext) RequestID() (ident1 string) {
	if _f17.RequestIDHook == nil {
		panic("Context.RequestID() called but FakeContext.RequestIDHook is nil")
	}

	invocation := new(ContextRequestIDInvocation)
	_f17.RequestIDCalls = append(_f17.RequestIDCalls, invocation)

	ident1 = _f17.RequestIDHook()

	invocation.Results.Ident1 = ident1

	return
}

// SetRequestIDStub configures Context.RequestID to always return the given values
func (_f18 *FakeContext) SetRequestIDStub(ident1 string) {
	_f18.RequestIDHook = func() string {
		return ident1
	}
}

// RequestIDCalled returns true if FakeContext.RequestID was called
func (f *FakeContext) RequestIDCalled() bool {
	return len(f.RequestIDCalls) != 0
}

// AssertRequestIDCalled calls t.Error if FakeContext.RequestID was not called
func (f *FakeContext) AssertRequestIDCalled(t ContextTestingT) {
	t.Helper()
	if len(f.RequestIDCalls) == 0 {
		t.Error("FakeContext.RequestID not called, expected at least one")
	}
}

// RequestIDNotCalled returns true if FakeContext.RequestID was not called
func (f *FakeContext) RequestIDNotCalled() bool {
	return len(f.RequestIDCalls) == 0
}

// AssertRequestIDNotCalled calls t.Error if FakeContext.RequestID was called
func (f *FakeContext) AssertRequestIDNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.RequestIDCalls) != 0 {
		t.Error("FakeContext.RequestID called, expected none")
	}
}

// RequestIDCalledOnce returns true if FakeContext.RequestID was called exactly once
func (f *FakeContext) RequestIDCalledOnce() bool {
	return len(f.RequestIDCalls) == 1
}

// AssertRequestIDCalledOnce calls t.Error if FakeContext.RequestID was not called exactly once
func (f *FakeContext) AssertRequestIDCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.RequestIDCalls) != 1 {
		t.Errorf("FakeContext.RequestID called %d times, expected 1", len(f.RequestIDCalls))
	}
}

// RequestIDCalledN returns true if FakeContext.RequestID was called at least n times
func (f *FakeContext) RequestIDCalledN(n int) bool {
	return len(f.RequestIDCalls) >= n
}

// AssertRequestIDCalledN calls t.Error if FakeContext.RequestID was called less than n times
func (f *FakeContext) AssertRequestIDCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.RequestIDCalls) < n {
		t.Errorf("FakeContext.RequestID called %d times, expected >= %d", len(f.RequestIDCalls), n)
	}
}

func (_f19 *FakeContext) Actor() (ident1 models.User) {
	if _f19.ActorHook == nil {
		panic("Context.Actor() called but FakeContext.ActorHook is nil")
	}

	invocation := new(ContextActorInvocation)
	_f19.ActorCalls = append(_f19.ActorCalls, invocation)

	ident1 = _f19.ActorHook()

	invocation.Results.Ident1 = ident1

	return
}

// SetActorStub configures Context.Actor to always return the given values
func (_f20 *FakeContext) SetActorStub(ident1 models.User) {
	_f20.ActorHook = func() models.User {
		return ident1
	}
}

// ActorCalled returns true if FakeContext.Actor was called
func (f *FakeContext) ActorCalled() bool {
	return len(f.ActorCalls) != 0
}

// AssertActorCalled calls t.Error if FakeContext.Actor was not called
func (f *FakeContext) AssertActorCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ActorCalls) == 0 {
		t.Error("FakeContext.Actor not called, expected at least one")
	}
}

// ActorNotCalled returns true if FakeContext.Actor was not called
func (f *FakeContext) ActorNotCalled() bool {
	return len(f.ActorCalls) == 0
}

// AssertActorNotCalled calls t.Error if FakeContext.Actor was called
func (f *FakeContext) AssertActorNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ActorCalls) != 0 {
		t.Error("FakeContext.Actor called, expected none")
	}
}

// ActorCalledOnce returns true if FakeContext.Actor was called exactly once
func (f *FakeContext) ActorCalledOnce() bool {
	return len(f.ActorCalls) == 1
}

// AssertActorCalledOnce calls t.Error if FakeContext.Actor was not called exactly once
func (f *FakeContext) AssertActorCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.ActorCalls) != 1 {
		t.Errorf("FakeContext.Actor called %d times, expected 1", len(f.ActorCalls))
	}
}

// ActorCalledN returns true if FakeContext.Actor was called at least n times
func (f *FakeContext) ActorCalledN(n int) bool {
	return len(f.ActorCalls) >= n
}

// AssertActorCalledN calls t.Error if FakeContext.Actor was called less than n times
func (f *FakeContext) AssertActorCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.ActorCalls) < n {
		t.Errorf("FakeContext.Actor called %d times, expected >= %d", len(f.ActorCalls), n)
	}
}

func (_f21 *FakeContext) Span() (ident1 opentracing.Span) {
	if _f21.SpanHook == nil {
		panic("Context.Span() called but FakeContext.SpanHook is nil")
	}

	invocation := new(ContextSpanInvocation)
	_f21.SpanCalls = append(_f21.SpanCalls, invocation)

	ident1 = _f21.SpanHook()

	invocation.Results.Ident1 = ident1

	return
}

// SetSpanStub configures Context.Span to always return the given values
func (_f22 *FakeContext) SetSpanStub(ident1 opentracing.Span) {
	_f22.SpanHook = func() opentracing.Span {
		return ident1
	}
}

// SpanCalled returns true if FakeContext.Span was called
func (f *FakeContext) SpanCalled() bool {
	return len(f.SpanCalls) != 0
}

// AssertSpanCalled calls t.Error if FakeContext.Span was not called
func (f *FakeContext) AssertSpanCalled(t ContextTestingT) {
	t.Helper()
	if len(f.SpanCalls) == 0 {
		t.Error("FakeContext.Span not called, expected at least one")
	}
}

// SpanNotCalled returns true if FakeContext.Span was not called
func (f *FakeContext) SpanNotCalled() bool {
	return len(f.SpanCalls) == 0
}

// AssertSpanNotCalled calls t.Error if FakeContext.Span was called
func (f *FakeContext) AssertSpanNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.SpanCalls) != 0 {
		t.Error("FakeContext.Span called, expected none")
	}
}

// SpanCalledOnce returns true if FakeContext.Span was called exactly once
func (f *FakeContext) SpanCalledOnce() bool {
	return len(f.SpanCalls) == 1
}

// AssertSpanCalledOnce calls t.Error if FakeContext.Span was not called exactly once
func (f *FakeContext) AssertSpanCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.SpanCalls) != 1 {
		t.Errorf("FakeContext.Span called %d times, expected 1", len(f.SpanCalls))
	}
}

// SpanCalledN returns true if FakeContext.Span was called at least n times
func (f *FakeContext) SpanCalledN(n int) bool {
	return len(f.SpanCalls) >= n
}

// AssertSpanCalledN calls t.Error if FakeContext.Span was called less than n times
func (f *FakeContext) AssertSpanCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.SpanCalls) < n {
		t.Errorf("FakeContext.Span called %d times, expected >= %d", len(f.SpanCalls), n)
	}
}

func (_f23 *FakeContext) StartSpan(ident1 string, ident2 ...opentracing.StartSpanOption) (ident3 opentracing.Span) {
	if _f23.StartSpanHook == nil {
		panic("Context.StartSpan() called but FakeContext.StartSpanHook is nil")
	}

	invocation := new(ContextStartSpanInvocation)
	_f23.StartSpanCalls = append(_f23.StartSpanCalls, invocation)

	invocation.Parameters.Ident1 = ident1
	invocation.Parameters.Ident2 = ident2

	ident3 = _f23.StartSpanHook(ident1, ident2...)

	invocation.Results.Ident3 = ident3

	return
}

// SetStartSpanStub configures Context.StartSpan to always return the given values
func (_f24 *FakeContext) SetStartSpanStub(ident3 opentracing.Span) {
	_f24.StartSpanHook = func(string, ...opentracing.StartSpanOption) opentracing.Span {
		return ident3
	}
}

// SetStartSpanInvocation configures Context.StartSpan to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f25 *FakeContext) SetStartSpanInvocation(calls_f26 []*ContextStartSpanInvocation, fallback_f27 func() opentracing.Span) {
	_f25.StartSpanHook = func(ident1 string, ident2 ...opentracing.StartSpanOption) (ident3 opentracing.Span) {
		for _, call := range calls_f26 {
			if reflect.DeepEqual(call.Parameters.Ident1, ident1) && reflect.DeepEqual(call.Parameters.Ident2, ident2) {
				ident3 = call.Results.Ident3

				return
			}
		}

		return fallback_f27()
	}
}

// StartSpanCalled returns true if FakeContext.StartSpan was called
func (f *FakeContext) StartSpanCalled() bool {
	return len(f.StartSpanCalls) != 0
}

// AssertStartSpanCalled calls t.Error if FakeContext.StartSpan was not called
func (f *FakeContext) AssertStartSpanCalled(t ContextTestingT) {
	t.Helper()
	if len(f.StartSpanCalls) == 0 {
		t.Error("FakeContext.StartSpan not called, expected at least one")
	}
}

// StartSpanNotCalled returns true if FakeContext.StartSpan was not called
func (f *FakeContext) StartSpanNotCalled() bool {
	return len(f.StartSpanCalls) == 0
}

// AssertStartSpanNotCalled calls t.Error if FakeContext.StartSpan was called
func (f *FakeContext) AssertStartSpanNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.StartSpanCalls) != 0 {
		t.Error("FakeContext.StartSpan called, expected none")
	}
}

// StartSpanCalledOnce returns true if FakeContext.StartSpan was called exactly once
func (f *FakeContext) StartSpanCalledOnce() bool {
	return len(f.StartSpanCalls) == 1
}

// AssertStartSpanCalledOnce calls t.Error if FakeContext.StartSpan was not called exactly once
func (f *FakeContext) AssertStartSpanCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.StartSpanCalls) != 1 {
		t.Errorf("FakeContext.StartSpan called %d times, expected 1", len(f.StartSpanCalls))
	}
}

// StartSpanCalledN returns true if FakeContext.StartSpan was called at least n times
func (f *FakeContext) StartSpanCalledN(n int) bool {
	return len(f.StartSpanCalls) >= n
}

// AssertStartSpanCalledN calls t.Error if FakeContext.StartSpan was called less than n times
func (f *FakeContext) AssertStartSpanCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.StartSpanCalls) < n {
		t.Errorf("FakeContext.StartSpan called %d times, expected >= %d", len(f.StartSpanCalls), n)
	}
}

// StartSpanCalledWith returns true if FakeContext.StartSpan was called with the given values
func (_f28 *FakeContext) StartSpanCalledWith(ident1 string, ident2 ...opentracing.StartSpanOption) (found bool) {
	for _, call := range _f28.StartSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) && reflect.DeepEqual(call.Parameters.Ident2, ident2) {
			found = true
			break
		}
	}

	return
}

// AssertStartSpanCalledWith calls t.Error if FakeContext.StartSpan was not called with the given values
func (_f29 *FakeContext) AssertStartSpanCalledWith(t ContextTestingT, ident1 string, ident2 ...opentracing.StartSpanOption) {
	t.Helper()
	var found bool
	for _, call := range _f29.StartSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) && reflect.DeepEqual(call.Parameters.Ident2, ident2) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.StartSpan not called with expected parameters")
	}
}

// StartSpanCalledOnceWith returns true if FakeContext.StartSpan was called exactly once with the given values
func (_f30 *FakeContext) StartSpanCalledOnceWith(ident1 string, ident2 ...opentracing.StartSpanOption) bool {
	var count int
	for _, call := range _f30.StartSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) && reflect.DeepEqual(call.Parameters.Ident2, ident2) {
			count++
		}
	}

	return count == 1
}

// AssertStartSpanCalledOnceWith calls t.Error if FakeContext.StartSpan was not called exactly once with the given values
func (_f31 *FakeContext) AssertStartSpanCalledOnceWith(t ContextTestingT, ident1 string, ident2 ...opentracing.StartSpanOption) {
	t.Helper()
	var count int
	for _, call := range _f31.StartSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) && reflect.DeepEqual(call.Parameters.Ident2, ident2) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.StartSpan called %d times with expected parameters, expected one", count)
	}
}

// StartSpanResultsForCall returns the result values for the first call to FakeContext.StartSpan with the given values
func (_f32 *FakeContext) StartSpanResultsForCall(ident1 string, ident2 ...opentracing.StartSpanOption) (ident3 opentracing.Span, found bool) {
	for _, call := range _f32.StartSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) && reflect.DeepEqual(call.Parameters.Ident2, ident2) {
			ident3 = call.Results.Ident3
			found = true
			break
		}
	}

	return
}

func (_f33 *FakeContext) WithParent(ident1 context.Context) (ident2 Context) {
	if _f33.WithParentHook == nil {
		panic("Context.WithParent() called but FakeContext.WithParentHook is nil")
	}

	invocation := new(ContextWithParentInvocation)
	_f33.WithParentCalls = append(_f33.WithParentCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2 = _f33.WithParentHook(ident1)

	invocation.Results.Ident2 = ident2

	return
}

// SetWithParentStub configures Context.WithParent to always return the given values
func (_f34 *FakeContext) SetWithParentStub(ident2 Context) {
	_f34.WithParentHook = func(context.Context) Context {
		return ident2
	}
}

// SetWithParentInvocation configures Context.WithParent to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f35 *FakeContext) SetWithParentInvocation(calls_f36 []*ContextWithParentInvocation, fallback_f37 func() Context) {
	_f35.WithParentHook = func(ident1 context.Context) (ident2 Context) {
		for _, call := range calls_f36 {
			if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
				ident2 = call.Results.Ident2

				return
			}
		}

		return fallback_f37()
	}
}

// WithParentCalled returns true if FakeContext.WithParent was called
func (f *FakeContext) WithParentCalled() bool {
	return len(f.WithParentCalls) != 0
}

// AssertWithParentCalled calls t.Error if FakeContext.WithParent was not called
func (f *FakeContext) AssertWithParentCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithParentCalls) == 0 {
		t.Error("FakeContext.WithParent not called, expected at least one")
	}
}

// WithParentNotCalled returns true if FakeContext.WithParent was not called
func (f *FakeContext) WithParentNotCalled() bool {
	return len(f.WithParentCalls) == 0
}

// AssertWithParentNotCalled calls t.Error if FakeContext.WithParent was called
func (f *FakeContext) AssertWithParentNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithParentCalls) != 0 {
		t.Error("FakeContext.WithParent called, expected none")
	}
}

// WithParentCalledOnce returns true if FakeContext.WithParent was called exactly once
func (f *FakeContext) WithParentCalledOnce() bool {
	return len(f.WithParentCalls) == 1
}

// AssertWithParentCalledOnce calls t.Error if FakeContext.WithParent was not called exactly once
func (f *FakeContext) AssertWithParentCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithParentCalls) != 1 {
		t.Errorf("FakeContext.WithParent called %d times, expected 1", len(f.WithParentCalls))
	}
}

// WithParentCalledN returns true if FakeContext.WithParent was called at least n times
func (f *FakeContext) WithParentCalledN(n int) bool {
	return len(f.WithParentCalls) >= n
}

// AssertWithParentCalledN calls t.Error if FakeContext.WithParent was called less than n times
func (f *FakeContext) AssertWithParentCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithParentCalls) < n {
		t.Errorf("FakeContext.WithParent called %d times, expected >= %d", len(f.WithParentCalls), n)
	}
}

// WithParentCalledWith returns true if FakeContext.WithParent was called with the given values
func (_f38 *FakeContext) WithParentCalledWith(ident1 context.Context) (found bool) {
	for _, call := range _f38.WithParentCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithParentCalledWith calls t.Error if FakeContext.WithParent was not called with the given values
func (_f39 *FakeContext) AssertWithParentCalledWith(t ContextTestingT, ident1 context.Context) {
	t.Helper()
	var found bool
	for _, call := range _f39.WithParentCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithParent not called with expected parameters")
	}
}

// WithParentCalledOnceWith returns true if FakeContext.WithParent was called exactly once with the given values
func (_f40 *FakeContext) WithParentCalledOnceWith(ident1 context.Context) bool {
	var count int
	for _, call := range _f40.WithParentCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithParentCalledOnceWith calls t.Error if FakeContext.WithParent was not called exactly once with the given values
func (_f41 *FakeContext) AssertWithParentCalledOnceWith(t ContextTestingT, ident1 context.Context) {
	t.Helper()
	var count int
	for _, call := range _f41.WithParentCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithParent called %d times with expected parameters, expected one", count)
	}
}

// WithParentResultsForCall returns the result values for the first call to FakeContext.WithParent with the given values
func (_f42 *FakeContext) WithParentResultsForCall(ident1 context.Context) (ident2 Context, found bool) {
	for _, call := range _f42.WithParentCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f43 *FakeContext) WithActor(ident1 models.User) (ident2 Context) {
	if _f43.WithActorHook == nil {
		panic("Context.WithActor() called but FakeContext.WithActorHook is nil")
	}

	invocation := new(ContextWithActorInvocation)
	_f43.WithActorCalls = append(_f43.WithActorCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2 = _f43.WithActorHook(ident1)

	invocation.Results.Ident2 = ident2

	return
}

// SetWithActorStub configures Context.WithActor to always return the given values
func (_f44 *FakeContext) SetWithActorStub(ident2 Context) {
	_f44.WithActorHook = func(models.User) Context {
		return ident2
	}
}

// SetWithActorInvocation configures Context.WithActor to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f45 *FakeContext) SetWithActorInvocation(calls_f46 []*ContextWithActorInvocation, fallback_f47 func() Context) {
	_f45.WithActorHook = func(ident1 models.User) (ident2 Context) {
		for _, call := range calls_f46 {
			if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
				ident2 = call.Results.Ident2

				return
			}
		}

		return fallback_f47()
	}
}

// WithActorCalled returns true if FakeContext.WithActor was called
func (f *FakeContext) WithActorCalled() bool {
	return len(f.WithActorCalls) != 0
}

// AssertWithActorCalled calls t.Error if FakeContext.WithActor was not called
func (f *FakeContext) AssertWithActorCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithActorCalls) == 0 {
		t.Error("FakeContext.WithActor not called, expected at least one")
	}
}

// WithActorNotCalled returns true if FakeContext.WithActor was not called
func (f *FakeContext) WithActorNotCalled() bool {
	return len(f.WithActorCalls) == 0
}

// AssertWithActorNotCalled calls t.Error if FakeContext.WithActor was called
func (f *FakeContext) AssertWithActorNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithActorCalls) != 0 {
		t.Error("FakeContext.WithActor called, expected none")
	}
}

// WithActorCalledOnce returns true if FakeContext.WithActor was called exactly once
func (f *FakeContext) WithActorCalledOnce() bool {
	return len(f.WithActorCalls) == 1
}

// AssertWithActorCalledOnce calls t.Error if FakeContext.WithActor was not called exactly once
func (f *FakeContext) AssertWithActorCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithActorCalls) != 1 {
		t.Errorf("FakeContext.WithActor called %d times, expected 1", len(f.WithActorCalls))
	}
}

// WithActorCalledN returns true if FakeContext.WithActor was called at least n times
func (f *FakeContext) WithActorCalledN(n int) bool {
	return len(f.WithActorCalls) >= n
}

// AssertWithActorCalledN calls t.Error if FakeContext.WithActor was called less than n times
func (f *FakeContext) AssertWithActorCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithActorCalls) < n {
		t.Errorf("FakeContext.WithActor called %d times, expected >= %d", len(f.WithActorCalls), n)
	}
}

// WithActorCalledWith returns true if FakeContext.WithActor was called with the given values
func (_f48 *FakeContext) WithActorCalledWith(ident1 models.User) (found bool) {
	for _, call := range _f48.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithActorCalledWith calls t.Error if FakeContext.WithActor was not called with the given values
func (_f49 *FakeContext) AssertWithActorCalledWith(t ContextTestingT, ident1 models.User) {
	t.Helper()
	var found bool
	for _, call := range _f49.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithActor not called with expected parameters")
	}
}

// WithActorCalledOnceWith returns true if FakeContext.WithActor was called exactly once with the given values
func (_f50 *FakeContext) WithActorCalledOnceWith(ident1 models.User) bool {
	var count int
	for _, call := range _f50.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithActorCalledOnceWith calls t.Error if FakeContext.WithActor was not called exactly once with the given values
func (_f51 *FakeContext) AssertWithActorCalledOnceWith(t ContextTestingT, ident1 models.User) {
	t.Helper()
	var count int
	for _, call := range _f51.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithActor called %d times with expected parameters, expected one", count)
	}
}

// WithActorResultsForCall returns the result values for the first call to FakeContext.WithActor with the given values
func (_f52 *FakeContext) WithActorResultsForCall(ident1 models.User) (ident2 Context, found bool) {
	for _, call := range _f52.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f53 *FakeContext) WithRequestID(ident1 string) (ident2 Context) {
	if _f53.WithRequestIDHook == nil {
		panic("Context.WithRequestID() called but FakeContext.WithRequestIDHook is nil")
	}

	invocation := new(ContextWithRequestIDInvocation)
	_f53.WithRequestIDCalls = append(_f53.WithRequestIDCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2 = _f53.WithRequestIDHook(ident1)

	invocation.Results.Ident2 = ident2

	return
}

// SetWithRequestIDStub configures Context.WithRequestID to always return the given values
func (_f54 *FakeContext) SetWithRequestIDStub(ident2 Context) {
	_f54.WithRequestIDHook = func(string) Context {
		return ident2
	}
}

// SetWithRequestIDInvocation configures Context.WithRequestID to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f55 *FakeContext) SetWithRequestIDInvocation(calls_f56 []*ContextWithRequestIDInvocation, fallback_f57 func() Context) {
	_f55.WithRequestIDHook = func(ident1 string) (ident2 Context) {
		for _, call := range calls_f56 {
			if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
				ident2 = call.Results.Ident2

				return
			}
		}

		return fallback_f57()
	}
}

// WithRequestIDCalled returns true if FakeContext.WithRequestID was called
func (f *FakeContext) WithRequestIDCalled() bool {
	return len(f.WithRequestIDCalls) != 0
}

// AssertWithRequestIDCalled calls t.Error if FakeContext.WithRequestID was not called
func (f *FakeContext) AssertWithRequestIDCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithRequestIDCalls) == 0 {
		t.Error("FakeContext.WithRequestID not called, expected at least one")
	}
}

// WithRequestIDNotCalled returns true if FakeContext.WithRequestID was not called
func (f *FakeContext) WithRequestIDNotCalled() bool {
	return len(f.WithRequestIDCalls) == 0
}

// AssertWithRequestIDNotCalled calls t.Error if FakeContext.WithRequestID was called
func (f *FakeContext) AssertWithRequestIDNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithRequestIDCalls) != 0 {
		t.Error("FakeContext.WithRequestID called, expected none")
	}
}

// WithRequestIDCalledOnce returns true if FakeContext.WithRequestID was called exactly once
func (f *FakeContext) WithRequestIDCalledOnce() bool {
	return len(f.WithRequestIDCalls) == 1
}

// AssertWithRequestIDCalledOnce calls t.Error if FakeContext.WithRequestID was not called exactly once
func (f *FakeContext) AssertWithRequestIDCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithRequestIDCalls) != 1 {
		t.Errorf("FakeContext.WithRequestID called %d times, expected 1", len(f.WithRequestIDCalls))
	}
}

// WithRequestIDCalledN returns true if FakeContext.WithRequestID was called at least n times
func (f *FakeContext) WithRequestIDCalledN(n int) bool {
	return len(f.WithRequestIDCalls) >= n
}

// AssertWithRequestIDCalledN calls t.Error if FakeContext.WithRequestID was called less than n times
func (f *FakeContext) AssertWithRequestIDCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithRequestIDCalls) < n {
		t.Errorf("FakeContext.WithRequestID called %d times, expected >= %d", len(f.WithRequestIDCalls), n)
	}
}

// WithRequestIDCalledWith returns true if FakeContext.WithRequestID was called with the given values
func (_f58 *FakeContext) WithRequestIDCalledWith(ident1 string) (found bool) {
	for _, call := range _f58.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithRequestIDCalledWith calls t.Error if FakeContext.WithRequestID was not called with the given values
func (_f59 *FakeContext) AssertWithRequestIDCalledWith(t ContextTestingT, ident1 string) {
	t.Helper()
	var found bool
	for _, call := range _f59.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithRequestID not called with expected parameters")
	}
}

// WithRequestIDCalledOnceWith returns true if FakeContext.WithRequestID was called exactly once with the given values
func (_f60 *FakeContext) WithRequestIDCalledOnceWith(ident1 string) bool {
	var count int
	for _, call := range _f60.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithRequestIDCalledOnceWith calls t.Error if FakeContext.WithRequestID was not called exactly once with the given values
func (_f61 *FakeContext) AssertWithRequestIDCalledOnceWith(t ContextTestingT, ident1 string) {
	t.Helper()
	var count int
	for _, call := range _f61.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithRequestID called %d times with expected parameters, expected one", count)
	}
}

// WithRequestIDResultsForCall returns the result values for the first call to FakeContext.WithRequestID with the given values
func (_f62 *FakeContext) WithRequestIDResultsForCall(ident1 string) (ident2 Context, found bool) {
	for _, call := range _f62.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f63 *FakeContext) WithSpan(ident1 opentracing.Span) (ident2 Context) {
	if _f63.WithSpanHook == nil {
		panic("Context.WithSpan() called but FakeContext.WithSpanHook is nil")
	}

	invocation := new(ContextWithSpanInvocation)
	_f63.WithSpanCalls = append(_f63.WithSpanCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2 = _f63.WithSpanHook(ident1)

	invocation.Results.Ident2 = ident2

	return
}

// SetWithSpanStub configures Context.WithSpan to always return the given values
func (_f64 *FakeContext) SetWithSpanStub(ident2 Context) {
	_f64.WithSpanHook = func(opentracing.Span) Context {
		return ident2
	}
}

// SetWithSpanInvocation configures Context.WithSpan to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f65 *FakeContext) SetWithSpanInvocation(calls_f66 []*ContextWithSpanInvocation, fallback_f67 func() Context) {
	_f65.WithSpanHook = func(ident1 opentracing.Span) (ident2 Context) {
		for _, call := range calls_f66 {
			if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
				ident2 = call.Results.Ident2

				return
			}
		}

		return fallback_f67()
	}
}

// WithSpanCalled returns true if FakeContext.WithSpan was called
func (f *FakeContext) WithSpanCalled() bool {
	return len(f.WithSpanCalls) != 0
}

// AssertWithSpanCalled calls t.Error if FakeContext.WithSpan was not called
func (f *FakeContext) AssertWithSpanCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithSpanCalls) == 0 {
		t.Error("FakeContext.WithSpan not called, expected at least one")
	}
}

// WithSpanNotCalled returns true if FakeContext.WithSpan was not called
func (f *FakeContext) WithSpanNotCalled() bool {
	return len(f.WithSpanCalls) == 0
}

// AssertWithSpanNotCalled calls t.Error if FakeContext.WithSpan was called
func (f *FakeContext) AssertWithSpanNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithSpanCalls) != 0 {
		t.Error("FakeContext.WithSpan called, expected none")
	}
}

// WithSpanCalledOnce returns true if FakeContext.WithSpan was called exactly once
func (f *FakeContext) WithSpanCalledOnce() bool {
	return len(f.WithSpanCalls) == 1
}

// AssertWithSpanCalledOnce calls t.Error if FakeContext.WithSpan was not called exactly once
func (f *FakeContext) AssertWithSpanCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithSpanCalls) != 1 {
		t.Errorf("FakeContext.WithSpan called %d times, expected 1", len(f.WithSpanCalls))
	}
}

// WithSpanCalledN returns true if FakeContext.WithSpan was called at least n times
func (f *FakeContext) WithSpanCalledN(n int) bool {
	return len(f.WithSpanCalls) >= n
}

// AssertWithSpanCalledN calls t.Error if FakeContext.WithSpan was called less than n times
func (f *FakeContext) AssertWithSpanCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithSpanCalls) < n {
		t.Errorf("FakeContext.WithSpan called %d times, expected >= %d", len(f.WithSpanCalls), n)
	}
}

// WithSpanCalledWith returns true if FakeContext.WithSpan was called with the given values
func (_f68 *FakeContext) WithSpanCalledWith(ident1 opentracing.Span) (found bool) {
	for _, call := range _f68.WithSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithSpanCalledWith calls t.Error if FakeContext.WithSpan was not called with the given values
func (_f69 *FakeContext) AssertWithSpanCalledWith(t ContextTestingT, ident1 opentracing.Span) {
	t.Helper()
	var found bool
	for _, call := range _f69.WithSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithSpan not called with expected parameters")
	}
}

// WithSpanCalledOnceWith returns true if FakeContext.WithSpan was called exactly once with the given values
func (_f70 *FakeContext) WithSpanCalledOnceWith(ident1 opentracing.Span) bool {
	var count int
	for _, call := range _f70.WithSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithSpanCalledOnceWith calls t.Error if FakeContext.WithSpan was not called exactly once with the given values
func (_f71 *FakeContext) AssertWithSpanCalledOnceWith(t ContextTestingT, ident1 opentracing.Span) {
	t.Helper()
	var count int
	for _, call := range _f71.WithSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithSpan called %d times with expected parameters, expected one", count)
	}
}

// WithSpanResultsForCall returns the result values for the first call to FakeContext.WithSpan with the given values
func (_f72 *FakeContext) WithSpanResultsForCall(ident1 opentracing.Span) (ident2 Context, found bool) {
	for _, call := range _f72.WithSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f73 *FakeContext) WithValue(key interface{}, value interface{}) (ident1 Context) {
	if _f73.WithValueHook == nil {
		panic("Context.WithValue() called but FakeContext.WithValueHook is nil")
	}

	invocation := new(ContextWithValueInvocation)
	_f73.WithValueCalls = append(_f73.WithValueCalls, invocation)

	invocation.Parameters.Key = key
	invocation.Parameters.Value = value

	ident1 = _f73.WithValueHook(key, value)

	invocation.Results.Ident1 = ident1

	return
}

// SetWithValueStub configures Context.WithValue to always return the given values
func (_f74 *FakeContext) SetWithValueStub(ident1 Context) {
	_f74.WithValueHook = func(interface{}, interface{}) Context {
		return ident1
	}
}

// SetWithValueInvocation configures Context.WithValue to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f75 *FakeContext) SetWithValueInvocation(calls_f76 []*ContextWithValueInvocation, fallback_f77 func() Context) {
	_f75.WithValueHook = func(key interface{}, value interface{}) (ident1 Context) {
		for _, call := range calls_f76 {
			if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
				ident1 = call.Results.Ident1

				return
			}
		}

		return fallback_f77()
	}
}

// WithValueCalled returns true if FakeContext.WithValue was called
func (f *FakeContext) WithValueCalled() bool {
	return len(f.WithValueCalls) != 0
}

// AssertWithValueCalled calls t.Error if FakeContext.WithValue was not called
func (f *FakeContext) AssertWithValueCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithValueCalls) == 0 {
		t.Error("FakeContext.WithValue not called, expected at least one")
	}
}

// WithValueNotCalled returns true if FakeContext.WithValue was not called
func (f *FakeContext) WithValueNotCalled() bool {
	return len(f.WithValueCalls) == 0
}

// AssertWithValueNotCalled calls t.Error if FakeContext.WithValue was called
func (f *FakeContext) AssertWithValueNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithValueCalls) != 0 {
		t.Error("FakeContext.WithValue called, expected none")
	}
}

// WithValueCalledOnce returns true if FakeContext.WithValue was called exactly once
func (f *FakeContext) WithValueCalledOnce() bool {
	return len(f.WithValueCalls) == 1
}

// AssertWithValueCalledOnce calls t.Error if FakeContext.WithValue was not called exactly once
func (f *FakeContext) AssertWithValueCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithValueCalls) != 1 {
		t.Errorf("FakeContext.WithValue called %d times, expected 1", len(f.WithValueCalls))
	}
}

// WithValueCalledN returns true if FakeContext.WithValue was called at least n times
func (f *FakeContext) WithValueCalledN(n int) bool {
	return len(f.WithValueCalls) >= n
}

// AssertWithValueCalledN calls t.Error if FakeContext.WithValue was called less than n times
func (f *FakeContext) AssertWithValueCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithValueCalls) < n {
		t.Errorf("FakeContext.WithValue called %d times, expected >= %d", len(f.WithValueCalls), n)
	}
}

// WithValueCalledWith returns true if FakeContext.WithValue was called with the given values
func (_f78 *FakeContext) WithValueCalledWith(key interface{}, value interface{}) (found bool) {
	for _, call := range _f78.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			found = true
			break
		}
	}

	return
}

// AssertWithValueCalledWith calls t.Error if FakeContext.WithValue was not called with the given values
func (_f79 *FakeContext) AssertWithValueCalledWith(t ContextTestingT, key interface{}, value interface{}) {
	t.Helper()
	var found bool
	for _, call := range _f79.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithValue not called with expected parameters")
	}
}

// WithValueCalledOnceWith returns true if FakeContext.WithValue was called exactly once with the given values
func (_f80 *FakeContext) WithValueCalledOnceWith(key interface{}, value interface{}) bool {
	var count int
	for _, call := range _f80.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			count++
		}
	}

	return count == 1
}

// AssertWithValueCalledOnceWith calls t.Error if FakeContext.WithValue was not called exactly once with the given values
func (_f81 *FakeContext) AssertWithValueCalledOnceWith(t ContextTestingT, key interface{}, value interface{}) {
	t.Helper()
	var count int
	for _, call := range _f81.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithValue called %d times with expected parameters, expected one", count)
	}
}

// WithValueResultsForCall returns the result values for the first call to FakeContext.WithValue with the given values
func (_f82 *FakeContext) WithValueResultsForCall(key interface{}, value interface{}) (ident1 Context, found bool) {
	for _, call := range _f82.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}

func (_f83 *FakeContext) WithCancel() (ident1 Context, ident2 context.CancelFunc) {
	if _f83.WithCancelHook == nil {
		panic("Context.WithCancel() called but FakeContext.WithCancelHook is nil")
	}

	invocation := new(ContextWithCancelInvocation)
	_f83.WithCancelCalls = append(_f83.WithCancelCalls, invocation)

	ident1, ident2 = _f83.WithCancelHook()

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return
}

// SetWithCancelStub configures Context.WithCancel to always return the given values
func (_f84 *FakeContext) SetWithCancelStub(ident1 Context, ident2 context.CancelFunc) {
	_f84.WithCancelHook = func() (Context, context.CancelFunc) {
		return ident1, ident2
	}
}

// WithCancelCalled returns true if FakeContext.WithCancel was called
func (f *FakeContext) WithCancelCalled() bool {
	return len(f.WithCancelCalls) != 0
}

// AssertWithCancelCalled calls t.Error if FakeContext.WithCancel was not called
func (f *FakeContext) AssertWithCancelCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithCancelCalls) == 0 {
		t.Error("FakeContext.WithCancel not called, expected at least one")
	}
}

// WithCancelNotCalled returns true if FakeContext.WithCancel was not called
func (f *FakeContext) WithCancelNotCalled() bool {
	return len(f.WithCancelCalls) == 0
}

// AssertWithCancelNotCalled calls t.Error if FakeContext.WithCancel was called
func (f *FakeContext) AssertWithCancelNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithCancelCalls) != 0 {
		t.Error("FakeContext.WithCancel called, expected none")
	}
}

// WithCancelCalledOnce returns true if FakeContext.WithCancel was called exactly once
func (f *FakeContext) WithCancelCalledOnce() bool {
	return len(f.WithCancelCalls) == 1
}

// AssertWithCancelCalledOnce calls t.Error if FakeContext.WithCancel was not called exactly once
func (f *FakeContext) AssertWithCancelCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithCancelCalls) != 1 {
		t.Errorf("FakeContext.WithCancel called %d times, expected 1", len(f.WithCancelCalls))
	}
}

// WithCancelCalledN returns true if FakeContext.WithCancel was called at least n times
func (f *FakeContext) WithCancelCalledN(n int) bool {
	return len(f.WithCancelCalls) >= n
}

// AssertWithCancelCalledN calls t.Error if FakeContext.WithCancel was called less than n times
func (f *FakeContext) AssertWithCancelCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithCancelCalls) < n {
		t.Errorf("FakeContext.WithCancel called %d times, expected >= %d", len(f.WithCancelCalls), n)
	}
}

func (_f85 *FakeContext) WithDeadline(ident1 time.Time) (ident2 Context, ident3 context.CancelFunc) {
	if _f85.WithDeadlineHook == nil {
		panic("Context.WithDeadline() called but FakeContext.WithDeadlineHook is nil")
	}

	invocation := new(ContextWithDeadlineInvocation)
	_f85.WithDeadlineCalls = append(_f85.WithDeadlineCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2, ident3 = _f85.WithDeadlineHook(ident1)

	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3

	return
}

// SetWithDeadlineStub configures Context.WithDeadline to always return the given values
func (_f86 *FakeContext) SetWithDeadlineStub(ident2 Context, ident3 context.CancelFunc) {
	_f86.WithDeadlineHook = func(time.Time) (Context, context.CancelFunc) {
		return ident2, ident3
	}
}

// SetWithDeadlineInvocation configures Context.WithDeadline to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f87 *FakeContext) SetWithDeadlineInvocation(calls_f88 []*ContextWithDeadlineInvocation, fallback_f89 func() (Context, context.CancelFunc)) {
	_f87.WithDeadlineHook = func(ident1 time.Time) (ident2 Context, ident3 context.CancelFunc) {
		for _, call := range calls_f88 {
			if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
				ident2 = call.Results.Ident2
				ident3 = call.Results.Ident3

				return
			}
		}

		return fallback_f89()
	}
}

// WithDeadlineCalled returns true if FakeContext.WithDeadline was called
func (f *FakeContext) WithDeadlineCalled() bool {
	return len(f.WithDeadlineCalls) != 0
}

// AssertWithDeadlineCalled calls t.Error if FakeContext.WithDeadline was not called
func (f *FakeContext) AssertWithDeadlineCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithDeadlineCalls) == 0 {
		t.Error("FakeContext.WithDeadline not called, expected at least one")
	}
}

// WithDeadlineNotCalled returns true if FakeContext.WithDeadline was not called
func (f *FakeContext) WithDeadlineNotCalled() bool {
	return len(f.WithDeadlineCalls) == 0
}

// AssertWithDeadlineNotCalled calls t.Error if FakeContext.WithDeadline was called
func (f *FakeContext) AssertWithDeadlineNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithDeadlineCalls) != 0 {
		t.Error("FakeContext.WithDeadline called, expected none")
	}
}

// WithDeadlineCalledOnce returns true if FakeContext.WithDeadline was called exactly once
func (f *FakeContext) WithDeadlineCalledOnce() bool {
	return len(f.WithDeadlineCalls) == 1
}

// AssertWithDeadlineCalledOnce calls t.Error if FakeContext.WithDeadline was not called exactly once
func (f *FakeContext) AssertWithDeadlineCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithDeadlineCalls) != 1 {
		t.Errorf("FakeContext.WithDeadline called %d times, expected 1", len(f.WithDeadlineCalls))
	}
}

// WithDeadlineCalledN returns true if FakeContext.WithDeadline was called at least n times
func (f *FakeContext) WithDeadlineCalledN(n int) bool {
	return len(f.WithDeadlineCalls) >= n
}

// AssertWithDeadlineCalledN calls t.Error if FakeContext.WithDeadline was called less than n times
func (f *FakeContext) AssertWithDeadlineCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithDeadlineCalls) < n {
		t.Errorf("FakeContext.WithDeadline called %d times, expected >= %d", len(f.WithDeadlineCalls), n)
	}
}

// WithDeadlineCalledWith returns true if FakeContext.WithDeadline was called with the given values
func (_f90 *FakeContext) WithDeadlineCalledWith(ident1 time.Time) (found bool) {
	for _, call := range _f90.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithDeadlineCalledWith calls t.Error if FakeContext.WithDeadline was not called with the given values
func (_f91 *FakeContext) AssertWithDeadlineCalledWith(t ContextTestingT, ident1 time.Time) {
	t.Helper()
	var found bool
	for _, call := range _f91.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithDeadline not called with expected parameters")
	}
}

// WithDeadlineCalledOnceWith returns true if FakeContext.WithDeadline was called exactly once with the given values
func (_f92 *FakeContext) WithDeadlineCalledOnceWith(ident1 time.Time) bool {
	var count int
	for _, call := range _f92.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithDeadlineCalledOnceWith calls t.Error if FakeContext.WithDeadline was not called exactly once with the given values
func (_f93 *FakeContext) AssertWithDeadlineCalledOnceWith(t ContextTestingT, ident1 time.Time) {
	t.Helper()
	var count int
	for _, call := range _f93.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithDeadline called %d times with expected parameters, expected one", count)
	}
}

// WithDeadlineResultsForCall returns the result values for the first call to FakeContext.WithDeadline with the given values
func (_f94 *FakeContext) WithDeadlineResultsForCall(ident1 time.Time) (ident2 Context, ident3 context.CancelFunc, found bool) {
	for _, call := range _f94.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			ident3 = call.Results.Ident3
			found = true
			break
		}
	}

	return
}

func (_f95 *FakeContext) WithTimeout(ident1 time.Duration) (ident2 Context, ident3 context.CancelFunc) {
	if _f95.WithTimeoutHook == nil {
		panic("Context.WithTimeout() called but FakeContext.WithTimeoutHook is nil")
	}

	invocation := new(ContextWithTimeoutInvocation)
	_f95.WithTimeoutCalls = append(_f95.WithTimeoutCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2, ident3 = _f95.WithTimeoutHook(ident1)

	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3

	return
}

// SetWithTimeoutStub configures Context.WithTimeout to always return the given values
func (_f96 *FakeContext) SetWithTimeoutStub(ident2 Context, ident3 context.CancelFunc) {
	_f96.WithTimeoutHook = func(time.Duration) (Context, context.CancelFunc) {
		return ident2, ident3
	}
}

// SetWithTimeoutInvocation configures Context.WithTimeout to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f97 *FakeContext) SetWithTimeoutInvocation(calls_f98 []*ContextWithTimeoutInvocation, fallback_f99 func() (Context, context.CancelFunc)) {
	_f97.WithTimeoutHook = func(ident1 time.Duration) (ident2 Context, ident3 context.CancelFunc) {
		for _, call := range calls_f98 {
			if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
				ident2 = call.Results.Ident2
				ident3 = call.Results.Ident3

				return
			}
		}

		return fallback_f99()
	}
}

// WithTimeoutCalled returns true if FakeContext.WithTimeout was called
func (f *FakeContext) WithTimeoutCalled() bool {
	return len(f.WithTimeoutCalls) != 0
}

// AssertWithTimeoutCalled calls t.Error if FakeContext.WithTimeout was not called
func (f *FakeContext) AssertWithTimeoutCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithTimeoutCalls) == 0 {
		t.Error("FakeContext.WithTimeout not called, expected at least one")
	}
}

// WithTimeoutNotCalled returns true if FakeContext.WithTimeout was not called
func (f *FakeContext) WithTimeoutNotCalled() bool {
	return len(f.WithTimeoutCalls) == 0
}

// AssertWithTimeoutNotCalled calls t.Error if FakeContext.WithTimeout was called
func (f *FakeContext) AssertWithTimeoutNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithTimeoutCalls) != 0 {
		t.Error("FakeContext.WithTimeout called, expected none")
	}
}

// WithTimeoutCalledOnce returns true if FakeContext.WithTimeout was called exactly once
func (f *FakeContext) WithTimeoutCalledOnce() bool {
	return len(f.WithTimeoutCalls) == 1
}

// AssertWithTimeoutCalledOnce calls t.Error if FakeContext.WithTimeout was not called exactly once
func (f *FakeContext) AssertWithTimeoutCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithTimeoutCalls) != 1 {
		t.Errorf("FakeContext.WithTimeout called %d times, expected 1", len(f.WithTimeoutCalls))
	}
}

// WithTimeoutCalledN returns true if FakeContext.WithTimeout was called at least n times
func (f *FakeContext) WithTimeoutCalledN(n int) bool {
	return len(f.WithTimeoutCalls) >= n
}

// AssertWithTimeoutCalledN calls t.Error if FakeContext.WithTimeout was called less than n times
func (f *FakeContext) AssertWithTimeoutCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithTimeoutCalls) < n {
		t.Errorf("FakeContext.WithTimeout called %d times, expected >= %d", len(f.WithTimeoutCalls), n)
	}
}

// WithTimeoutCalledWith returns true if FakeContext.WithTimeout was called with the given values
func (_f100 *FakeContext) WithTimeoutCalledWith(ident1 time.Duration) (found bool) {
	for _, call := range _f100.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithTimeoutCalledWith calls t.Error if FakeContext.WithTimeout was not called with the given values
func (_f101 *FakeContext) AssertWithTimeoutCalledWith(t ContextTestingT, ident1 time.Duration) {
	t.Helper()
	var found bool
	for _, call := range _f101.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithTimeout not called with expected parameters")
	}
}

// WithTimeoutCalledOnceWith returns true if FakeContext.WithTimeout was called exactly once with the given values
func (_f102 *FakeContext) WithTimeoutCalledOnceWith(ident1 time.Duration) bool {
	var count int
	for _, call := range _f102.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithTimeoutCalledOnceWith calls t.Error if FakeContext.WithTimeout was not called exactly once with the given values
func (_f103 *FakeContext) AssertWithTimeoutCalledOnceWith(t ContextTestingT, ident1 time.Duration) {
	t.Helper()
	var count int
	for _, call := range _f103.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithTimeout called %d times with expected parameters, expected one", count)
	}
}

// WithTimeoutResultsForCall returns the result values for the first call to FakeContext.WithTimeout with the given values
func (_f104 *FakeContext) WithTimeoutResultsForCall(ident1 time.Duration) (ident2 Context, ident3 context.CancelFunc, found bool) {
	for _, call := range _f104.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			ident3 = call.Results.Ident3
			found = true
			break
		}
	}

	return
}
