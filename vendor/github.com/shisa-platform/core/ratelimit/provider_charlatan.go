// generated by "charlatan -output=./provider_charlatan.go Provider".  DO NOT EDIT.

package ratelimit

import "reflect"
import "github.com/ansel1/merry"
import "time"
import "github.com/shisa-platform/core/context"

// ProviderLimitInvocation represents a single call of FakeProvider.Limit
type ProviderLimitInvocation struct {
	Parameters struct {
		Ctx    context.Context
		Actor  string
		Action string
		Path   string
	}
	Results struct {
		Ident1 RateLimit
		Ident2 merry.Error
	}
}

// NewProviderLimitInvocation creates a new instance of ProviderLimitInvocation
func NewProviderLimitInvocation(ctx context.Context, actor string, action string, path string, ident1 RateLimit, ident2 merry.Error) *ProviderLimitInvocation {
	invocation := new(ProviderLimitInvocation)

	invocation.Parameters.Ctx = ctx
	invocation.Parameters.Actor = actor
	invocation.Parameters.Action = action
	invocation.Parameters.Path = path

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// ProviderAllowInvocation represents a single call of FakeProvider.Allow
type ProviderAllowInvocation struct {
	Parameters struct {
		Ctx    context.Context
		Actor  string
		Action string
		Path   string
	}
	Results struct {
		Ident1 bool
		Ident2 time.Duration
		Ident3 merry.Error
	}
}

// NewProviderAllowInvocation creates a new instance of ProviderAllowInvocation
func NewProviderAllowInvocation(ctx context.Context, actor string, action string, path string, ident1 bool, ident2 time.Duration, ident3 merry.Error) *ProviderAllowInvocation {
	invocation := new(ProviderAllowInvocation)

	invocation.Parameters.Ctx = ctx
	invocation.Parameters.Actor = actor
	invocation.Parameters.Action = action
	invocation.Parameters.Path = path

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3

	return invocation
}

// ProviderCloseInvocation represents a single call of FakeProvider.Close
type ProviderCloseInvocation struct {
}

// ProviderTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type ProviderTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeProvider is a mock implementation of Provider for testing.
Use it in your tests as in this example:

	package example

	func TestWithProvider(t *testing.T) {
		f := &ratelimit.FakeProvider{
			LimitHook: func(ctx context.Context, actor string, action string, path string) (ident1 RateLimit, ident2 merry.Error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeLimit ...
		f.AssertLimitCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeLimit.
*/
type FakeProvider struct {
	LimitHook func(context.Context, string, string, string) (RateLimit, merry.Error)
	AllowHook func(context.Context, string, string, string) (bool, time.Duration, merry.Error)
	CloseHook func()

	LimitCalls []*ProviderLimitInvocation
	AllowCalls []*ProviderAllowInvocation
	CloseCalls []*ProviderCloseInvocation
}

// NewFakeProviderDefaultPanic returns an instance of FakeProvider with all hooks configured to panic
func NewFakeProviderDefaultPanic() *FakeProvider {
	return &FakeProvider{
		LimitHook: func(context.Context, string, string, string) (ident1 RateLimit, ident2 merry.Error) {
			panic("Unexpected call to Provider.Limit")
		},
		AllowHook: func(context.Context, string, string, string) (ident1 bool, ident2 time.Duration, ident3 merry.Error) {
			panic("Unexpected call to Provider.Allow")
		},
		CloseHook: func() {
			panic("Unexpected call to Provider.Close")
		},
	}
}

// NewFakeProviderDefaultFatal returns an instance of FakeProvider with all hooks configured to call t.Fatal
func NewFakeProviderDefaultFatal(t ProviderTestingT) *FakeProvider {
	return &FakeProvider{
		LimitHook: func(context.Context, string, string, string) (ident1 RateLimit, ident2 merry.Error) {
			t.Fatal("Unexpected call to Provider.Limit")
			return
		},
		AllowHook: func(context.Context, string, string, string) (ident1 bool, ident2 time.Duration, ident3 merry.Error) {
			t.Fatal("Unexpected call to Provider.Allow")
			return
		},
		CloseHook: func() {
			t.Fatal("Unexpected call to Provider.Close")
			return
		},
	}
}

// NewFakeProviderDefaultError returns an instance of FakeProvider with all hooks configured to call t.Error
func NewFakeProviderDefaultError(t ProviderTestingT) *FakeProvider {
	return &FakeProvider{
		LimitHook: func(context.Context, string, string, string) (ident1 RateLimit, ident2 merry.Error) {
			t.Error("Unexpected call to Provider.Limit")
			return
		},
		AllowHook: func(context.Context, string, string, string) (ident1 bool, ident2 time.Duration, ident3 merry.Error) {
			t.Error("Unexpected call to Provider.Allow")
			return
		},
		CloseHook: func() {
			t.Error("Unexpected call to Provider.Close")
			return
		},
	}
}

func (f *FakeProvider) Reset() {
	f.LimitCalls = []*ProviderLimitInvocation{}
	f.AllowCalls = []*ProviderAllowInvocation{}
	f.CloseCalls = []*ProviderCloseInvocation{}
}

func (_f1 *FakeProvider) Limit(ctx context.Context, actor string, action string, path string) (ident1 RateLimit, ident2 merry.Error) {
	if _f1.LimitHook == nil {
		panic("Provider.Limit() called but FakeProvider.LimitHook is nil")
	}

	invocation := new(ProviderLimitInvocation)
	_f1.LimitCalls = append(_f1.LimitCalls, invocation)

	invocation.Parameters.Ctx = ctx
	invocation.Parameters.Actor = actor
	invocation.Parameters.Action = action
	invocation.Parameters.Path = path

	ident1, ident2 = _f1.LimitHook(ctx, actor, action, path)

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return
}

// SetLimitStub configures Provider.Limit to always return the given values
func (_f2 *FakeProvider) SetLimitStub(ident1 RateLimit, ident2 merry.Error) {
	_f2.LimitHook = func(context.Context, string, string, string) (RateLimit, merry.Error) {
		return ident1, ident2
	}
}

// SetLimitInvocation configures Provider.Limit to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f3 *FakeProvider) SetLimitInvocation(calls_f4 []*ProviderLimitInvocation, fallback_f5 func() (RateLimit, merry.Error)) {
	_f3.LimitHook = func(ctx context.Context, actor string, action string, path string) (ident1 RateLimit, ident2 merry.Error) {
		for _, call := range calls_f4 {
			if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
				ident1 = call.Results.Ident1
				ident2 = call.Results.Ident2

				return
			}
		}

		return fallback_f5()
	}
}

// LimitCalled returns true if FakeProvider.Limit was called
func (f *FakeProvider) LimitCalled() bool {
	return len(f.LimitCalls) != 0
}

// AssertLimitCalled calls t.Error if FakeProvider.Limit was not called
func (f *FakeProvider) AssertLimitCalled(t ProviderTestingT) {
	t.Helper()
	if len(f.LimitCalls) == 0 {
		t.Error("FakeProvider.Limit not called, expected at least one")
	}
}

// LimitNotCalled returns true if FakeProvider.Limit was not called
func (f *FakeProvider) LimitNotCalled() bool {
	return len(f.LimitCalls) == 0
}

// AssertLimitNotCalled calls t.Error if FakeProvider.Limit was called
func (f *FakeProvider) AssertLimitNotCalled(t ProviderTestingT) {
	t.Helper()
	if len(f.LimitCalls) != 0 {
		t.Error("FakeProvider.Limit called, expected none")
	}
}

// LimitCalledOnce returns true if FakeProvider.Limit was called exactly once
func (f *FakeProvider) LimitCalledOnce() bool {
	return len(f.LimitCalls) == 1
}

// AssertLimitCalledOnce calls t.Error if FakeProvider.Limit was not called exactly once
func (f *FakeProvider) AssertLimitCalledOnce(t ProviderTestingT) {
	t.Helper()
	if len(f.LimitCalls) != 1 {
		t.Errorf("FakeProvider.Limit called %d times, expected 1", len(f.LimitCalls))
	}
}

// LimitCalledN returns true if FakeProvider.Limit was called at least n times
func (f *FakeProvider) LimitCalledN(n int) bool {
	return len(f.LimitCalls) >= n
}

// AssertLimitCalledN calls t.Error if FakeProvider.Limit was called less than n times
func (f *FakeProvider) AssertLimitCalledN(t ProviderTestingT, n int) {
	t.Helper()
	if len(f.LimitCalls) < n {
		t.Errorf("FakeProvider.Limit called %d times, expected >= %d", len(f.LimitCalls), n)
	}
}

// LimitCalledWith returns true if FakeProvider.Limit was called with the given values
func (_f6 *FakeProvider) LimitCalledWith(ctx context.Context, actor string, action string, path string) (found bool) {
	for _, call := range _f6.LimitCalls {
		if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
			found = true
			break
		}
	}

	return
}

// AssertLimitCalledWith calls t.Error if FakeProvider.Limit was not called with the given values
func (_f7 *FakeProvider) AssertLimitCalledWith(t ProviderTestingT, ctx context.Context, actor string, action string, path string) {
	t.Helper()
	var found bool
	for _, call := range _f7.LimitCalls {
		if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeProvider.Limit not called with expected parameters")
	}
}

// LimitCalledOnceWith returns true if FakeProvider.Limit was called exactly once with the given values
func (_f8 *FakeProvider) LimitCalledOnceWith(ctx context.Context, actor string, action string, path string) bool {
	var count int
	for _, call := range _f8.LimitCalls {
		if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
			count++
		}
	}

	return count == 1
}

// AssertLimitCalledOnceWith calls t.Error if FakeProvider.Limit was not called exactly once with the given values
func (_f9 *FakeProvider) AssertLimitCalledOnceWith(t ProviderTestingT, ctx context.Context, actor string, action string, path string) {
	t.Helper()
	var count int
	for _, call := range _f9.LimitCalls {
		if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeProvider.Limit called %d times with expected parameters, expected one", count)
	}
}

// LimitResultsForCall returns the result values for the first call to FakeProvider.Limit with the given values
func (_f10 *FakeProvider) LimitResultsForCall(ctx context.Context, actor string, action string, path string) (ident1 RateLimit, ident2 merry.Error, found bool) {
	for _, call := range _f10.LimitCalls {
		if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
			ident1 = call.Results.Ident1
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f11 *FakeProvider) Allow(ctx context.Context, actor string, action string, path string) (ident1 bool, ident2 time.Duration, ident3 merry.Error) {
	if _f11.AllowHook == nil {
		panic("Provider.Allow() called but FakeProvider.AllowHook is nil")
	}

	invocation := new(ProviderAllowInvocation)
	_f11.AllowCalls = append(_f11.AllowCalls, invocation)

	invocation.Parameters.Ctx = ctx
	invocation.Parameters.Actor = actor
	invocation.Parameters.Action = action
	invocation.Parameters.Path = path

	ident1, ident2, ident3 = _f11.AllowHook(ctx, actor, action, path)

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3

	return
}

// SetAllowStub configures Provider.Allow to always return the given values
func (_f12 *FakeProvider) SetAllowStub(ident1 bool, ident2 time.Duration, ident3 merry.Error) {
	_f12.AllowHook = func(context.Context, string, string, string) (bool, time.Duration, merry.Error) {
		return ident1, ident2, ident3
	}
}

// SetAllowInvocation configures Provider.Allow to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (_f13 *FakeProvider) SetAllowInvocation(calls_f14 []*ProviderAllowInvocation, fallback_f15 func() (bool, time.Duration, merry.Error)) {
	_f13.AllowHook = func(ctx context.Context, actor string, action string, path string) (ident1 bool, ident2 time.Duration, ident3 merry.Error) {
		for _, call := range calls_f14 {
			if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
				ident1 = call.Results.Ident1
				ident2 = call.Results.Ident2
				ident3 = call.Results.Ident3

				return
			}
		}

		return fallback_f15()
	}
}

// AllowCalled returns true if FakeProvider.Allow was called
func (f *FakeProvider) AllowCalled() bool {
	return len(f.AllowCalls) != 0
}

// AssertAllowCalled calls t.Error if FakeProvider.Allow was not called
func (f *FakeProvider) AssertAllowCalled(t ProviderTestingT) {
	t.Helper()
	if len(f.AllowCalls) == 0 {
		t.Error("FakeProvider.Allow not called, expected at least one")
	}
}

// AllowNotCalled returns true if FakeProvider.Allow was not called
func (f *FakeProvider) AllowNotCalled() bool {
	return len(f.AllowCalls) == 0
}

// AssertAllowNotCalled calls t.Error if FakeProvider.Allow was called
func (f *FakeProvider) AssertAllowNotCalled(t ProviderTestingT) {
	t.Helper()
	if len(f.AllowCalls) != 0 {
		t.Error("FakeProvider.Allow called, expected none")
	}
}

// AllowCalledOnce returns true if FakeProvider.Allow was called exactly once
func (f *FakeProvider) AllowCalledOnce() bool {
	return len(f.AllowCalls) == 1
}

// AssertAllowCalledOnce calls t.Error if FakeProvider.Allow was not called exactly once
func (f *FakeProvider) AssertAllowCalledOnce(t ProviderTestingT) {
	t.Helper()
	if len(f.AllowCalls) != 1 {
		t.Errorf("FakeProvider.Allow called %d times, expected 1", len(f.AllowCalls))
	}
}

// AllowCalledN returns true if FakeProvider.Allow was called at least n times
func (f *FakeProvider) AllowCalledN(n int) bool {
	return len(f.AllowCalls) >= n
}

// AssertAllowCalledN calls t.Error if FakeProvider.Allow was called less than n times
func (f *FakeProvider) AssertAllowCalledN(t ProviderTestingT, n int) {
	t.Helper()
	if len(f.AllowCalls) < n {
		t.Errorf("FakeProvider.Allow called %d times, expected >= %d", len(f.AllowCalls), n)
	}
}

// AllowCalledWith returns true if FakeProvider.Allow was called with the given values
func (_f16 *FakeProvider) AllowCalledWith(ctx context.Context, actor string, action string, path string) (found bool) {
	for _, call := range _f16.AllowCalls {
		if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
			found = true
			break
		}
	}

	return
}

// AssertAllowCalledWith calls t.Error if FakeProvider.Allow was not called with the given values
func (_f17 *FakeProvider) AssertAllowCalledWith(t ProviderTestingT, ctx context.Context, actor string, action string, path string) {
	t.Helper()
	var found bool
	for _, call := range _f17.AllowCalls {
		if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeProvider.Allow not called with expected parameters")
	}
}

// AllowCalledOnceWith returns true if FakeProvider.Allow was called exactly once with the given values
func (_f18 *FakeProvider) AllowCalledOnceWith(ctx context.Context, actor string, action string, path string) bool {
	var count int
	for _, call := range _f18.AllowCalls {
		if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
			count++
		}
	}

	return count == 1
}

// AssertAllowCalledOnceWith calls t.Error if FakeProvider.Allow was not called exactly once with the given values
func (_f19 *FakeProvider) AssertAllowCalledOnceWith(t ProviderTestingT, ctx context.Context, actor string, action string, path string) {
	t.Helper()
	var count int
	for _, call := range _f19.AllowCalls {
		if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeProvider.Allow called %d times with expected parameters, expected one", count)
	}
}

// AllowResultsForCall returns the result values for the first call to FakeProvider.Allow with the given values
func (_f20 *FakeProvider) AllowResultsForCall(ctx context.Context, actor string, action string, path string) (ident1 bool, ident2 time.Duration, ident3 merry.Error, found bool) {
	for _, call := range _f20.AllowCalls {
		if reflect.DeepEqual(call.Parameters.Ctx, ctx) && reflect.DeepEqual(call.Parameters.Actor, actor) && reflect.DeepEqual(call.Parameters.Action, action) && reflect.DeepEqual(call.Parameters.Path, path) {
			ident1 = call.Results.Ident1
			ident2 = call.Results.Ident2
			ident3 = call.Results.Ident3
			found = true
			break
		}
	}

	return
}

func (_f21 *FakeProvider) Close() {
	if _f21.CloseHook == nil {
		panic("Provider.Close() called but FakeProvider.CloseHook is nil")
	}

	invocation := new(ProviderCloseInvocation)
	_f21.CloseCalls = append(_f21.CloseCalls, invocation)

	_f21.CloseHook()

	return
}

// CloseCalled returns true if FakeProvider.Close was called
func (f *FakeProvider) CloseCalled() bool {
	return len(f.CloseCalls) != 0
}

// AssertCloseCalled calls t.Error if FakeProvider.Close was not called
func (f *FakeProvider) AssertCloseCalled(t ProviderTestingT) {
	t.Helper()
	if len(f.CloseCalls) == 0 {
		t.Error("FakeProvider.Close not called, expected at least one")
	}
}

// CloseNotCalled returns true if FakeProvider.Close was not called
func (f *FakeProvider) CloseNotCalled() bool {
	return len(f.CloseCalls) == 0
}

// AssertCloseNotCalled calls t.Error if FakeProvider.Close was called
func (f *FakeProvider) AssertCloseNotCalled(t ProviderTestingT) {
	t.Helper()
	if len(f.CloseCalls) != 0 {
		t.Error("FakeProvider.Close called, expected none")
	}
}

// CloseCalledOnce returns true if FakeProvider.Close was called exactly once
func (f *FakeProvider) CloseCalledOnce() bool {
	return len(f.CloseCalls) == 1
}

// AssertCloseCalledOnce calls t.Error if FakeProvider.Close was not called exactly once
func (f *FakeProvider) AssertCloseCalledOnce(t ProviderTestingT) {
	t.Helper()
	if len(f.CloseCalls) != 1 {
		t.Errorf("FakeProvider.Close called %d times, expected 1", len(f.CloseCalls))
	}
}

// CloseCalledN returns true if FakeProvider.Close was called at least n times
func (f *FakeProvider) CloseCalledN(n int) bool {
	return len(f.CloseCalls) >= n
}

// AssertCloseCalledN calls t.Error if FakeProvider.Close was called less than n times
func (f *FakeProvider) AssertCloseCalledN(t ProviderTestingT, n int) {
	t.Helper()
	if len(f.CloseCalls) < n {
		t.Errorf("FakeProvider.Close called %d times, expected >= %d", len(f.CloseCalls), n)
	}
}
